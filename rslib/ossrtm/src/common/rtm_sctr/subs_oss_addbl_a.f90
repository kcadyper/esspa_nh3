!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.1 (r2757) - 01/12/09 17:50
!
MODULE SUBS_OSS_ADDBL_A
  USE type_kinds, ONLY: Single, Double, Quad, FP
  use params_module, ONLY: mxcang, mxang, mxang2, one_dp &
       , maxcmu !needed for packing calls and routines
  use subs_oss_addbl
  IMPLICIT NONE
  PUBLIC

  integer, save :: fac_pp !factor for push/pop real4 calls
  integer, save :: count = 0
  integer, save :: maxcount = 0

  integer, save :: realCount = 0
  integer, save :: maxRealCount = 0
  real(fp), parameter :: two=2_FP


interface LOC_PUSHREAL4ARRAY
         module procedure LOC_PUSHREAL4ARRAY1D, LOC_PUSHREAL4ARRAY2D
end interface

interface LOC_POPREAL4ARRAY
         module procedure LOC_POPREAL4ARRAY1D, LOC_POPREAL4ARRAY2D
end interface

CONTAINS

  subroutine LOC_PUSHREAL4ARRAY1D(array, length)
      real(fp), dimension(:) :: array
      integer :: length
      call PUSHREAL4ARRAY(array, length)
      count = count + length
      if (count .gt. maxcount) then
        maxcount = count
      end if
      return
  end subroutine LOC_PUSHREAL4ARRAY1D
  subroutine LOC_PUSHREAL4ARRAY2D(array, length)
      real(fp), dimension(:,:) :: array
      integer :: length
      call PUSHREAL4ARRAY(array, length)
      if (count .gt. maxcount) then
        maxcount = count
      end if
      return
  end subroutine LOC_PUSHREAL4ARRAY2D

  subroutine LOC_POPREAL4ARRAY1D(array, length)
      real(fp), dimension(:) :: array
      integer :: length
      call POPREAL4ARRAY(array, length)
      count = count - length
      return
  end subroutine LOC_POPREAL4ARRAY1D
  subroutine LOC_POPREAL4ARRAY2D(array, length)
      real(fp), dimension(:,:) :: array
      integer :: length
      call POPREAL4ARRAY(array, length)
      count = count - length
      return
  end subroutine LOC_POPREAL4ARRAY2D


  subroutine init_fac_pp()
    implicit none
    if (fp .eq. Single) then
       fac_pp=1
    elseif (fp .eq. Double) then
       fac_pp=2
!!$    elseif (fp .eq. Quad) then
!!$       fac_pp=4
    else
       write (*,*) 'invalid value of fp=',fp
       stop 'invalid value of fp'
    end if
  end subroutine init_fac_pp

  subroutine pushrealfp(x)
    implicit none
    real(fp) :: x
    if (fp .eq. Single) then
       call pushreal4(x)
    elseif (fp .eq. Double) then
       call pushreal8(x)
!!$    elseif (fp .eq. Quad) then
!!$       call pushreal16(x)
    end if
     realCount = realCount + 1
      if (realCount .gt. maxRealCount) then
        maxRealCount = realCount
      end if

  end subroutine pushrealfp

  subroutine poprealfp(x)
    implicit none
    real(fp) :: x
    if (fp .eq. Single) then
       call popreal4(x)
    elseif (fp .eq. Double) then
       call popreal8(x)
!!$    elseif (fp .eq. Quad) then
!!$       call popreal16(x)
    end if
     realCount = realCount - 1
  end subroutine poprealfp

!  Differentiation of surfce in reverse (adjoint) mode:
!   gradient, with respect to input variables: f0 r salb tsfc em
!   of linear combination of output variables: r em
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     OSS (Optimal Spectral Sampling)
!     $Name:  $
!     $Id: oss_addbl.f90,v 1.6 2009/04/03 20:21:19 crichard Exp $
!     Copyright AER, Inc., 2002, 2003. All rights Reserved.
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE SURFCE_A(maz, isrfl, tsfc, tsfc_a, salb, salb_a, f0, f0_a, r&
       , r_a, em, em_a, refls, vn, emissivity)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   SURFCE
!
! PURPOSE:
!
!   Subroutine initializes the reflection matrix and emission vector for the
!   lower atmosphere.
!
! SYNTAX:
!
!   CALL SURFCE(MAZ, ISRFL, TSFC, SALB, F0, R, EM, REFLS, VN)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   MAZ    INTEGER  Index for azimuthal direction in scattering calculations
!   ISRFL  INTEGER  Integer for setting reflectance flags
!   TSFC   REAL(FP)     Surface-level air temperature
!   SALB   REAL(FP)     Albedo
!   F0     REAL(FP)     solar irradiance at top of scattering layer
!   VN     REAL(Double)   Wavenumber, units of cm^-1
!
!   INPUTS/OUTPUTS:
!
!   R      REAL(FP)     Reflection matrix at NBOT0/NBOT
!   EM     REAL(FP)     Emission vector at NBOT0/NBOT
!   REFLS  LOGICAL  Flag for calculating surface reflectance
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     This subroutine initializes the reflection matrix (R) and emission
!     vector (EM) for the lower atmosphere by applying boundary conditions
!     at the surface. The current version treats Lambertian surfaces only.
!
!     MODIFIED:  21 MARCH 1995 to implement spectral interpolation
!                of surface properties within panel
!
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
   real(fp)                 :: emissivity

    INTEGER, INTENT(IN) :: maz, isrfl
    REAL(fp) :: tsfc, salb, f0
    REAL(fp) :: tsfc_a, salb_a, f0_a
    INTEGER :: nang
    REAL(fp), DIMENSION(nang, nang), INTENT(INOUT) :: r
    REAL(fp), DIMENSION(nang, nang) :: r_a
    REAL(fp), DIMENSION(nang) :: em
    REAL(fp), DIMENSION(nang) :: em_a
    REAL(DOUBLE), INTENT(IN) :: vn
    LOGICAL, INTENT(INOUT) :: refls
    LOGICAL :: plnck, sbeam
    REAL(fp) :: ylm0
    REAL(fp) :: pth
    REAL(fp) :: ylm
    REAL(fp) :: gmu
    REAL(fp) :: gwt
    REAL(fp) :: gmu0
    COMMON /angl/ pth(mxang), gmu(mxang), gwt(mxang), gmu0, ylm(0:2*&
&    mxcang-1, mxang), ylm0(0:2*mxcang-1)
    save /angl/
    REAL(fp) :: cl2inv
    REAL(fp) :: pi
    COMMON /constn/ pi, cl2inv
    save /constn/
    COMMON /lpar/ plnck, sbeam
    save /lpar/
    INTEGER :: nang2
    INTEGER :: n2ang
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    REAL(fp) :: rs
    REAL(fp) :: rs_a
    INTEGER :: j
    REAL(fp) :: fac
    INTEGER :: i
    REAL(fp) :: b
    REAL(fp) :: b_a
    REAL(fp) :: wk
    REAL(fp) :: wk_a
    INTEGER :: branch
!
    ! initialize local adjoint variables
    b_a=0.
    rs_a=0.
    wk_a=0.
!
    refls = .false.
!
!
  IF (isrfl .EQ. -99) THEN
!!$    f0_a = 0.0
!!$    salb_a = 0.0
!!$    tsfc_a = 0.0
  ELSE IF (maz .GT. 0) THEN
!!$    f0_a = 0.0
!!$    salb_a = 0.0
!!$    tsfc_a = 0.0
  ELSE
!
    rs = 0.
!
    IF (isrfl .EQ. -1) THEN
!
! *** Calculate surface reflectance across panel
!
      rs = salb
      refls = .true.
      CALL PUSHINTEGER4(0)
    ELSE IF (isrfl .EQ. 2) THEN
       rs = salb
       refls = .true.
      CALL PUSHINTEGER4(0)
!       print *, 'subs_oss_addbl_af90:249: isrfl == 2'
    ELSE
      CALL PUSHINTEGER4(1)
    END IF
!
! *** Calculate reflection matrix
!
    IF (refls) THEN
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
!
! *** Initialize EM by combining thermal emission and reflection of direct
! *** solar beam at the surface
!
    IF (plnck) THEN
      b = WNPLAN(vn, tsfc)
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
!
    IF (sbeam .AND. refls) THEN
      fac = gmu0/pi
      wk_a = 0.0
      DO i=nang,1,-1
        wk_a = wk_a + em_a(i)
      END DO
      rs_a = rs_a + fac*f0*wk_a
      f0_a = f0_a + fac*rs*wk_a
!!$    ELSE
!!$      f0_a = 0.0
!!$      rs_a = 0.0
    END IF
    CALL POPINTEGER4(branch)
    IF (branch .LT. 1) THEN
!!$      tsfc_a = 0.0
    ELSE
      wk_a = 0.0
      DO i=nang,1,-1
        wk_a = wk_a + em_a(i)
        em_a(i) = 0.0
      END DO
      rs_a = rs_a - b*wk_a
      b_a = b_a + emissivity*wk_a
      CALL WNPLAN_A0(vn, tsfc, tsfc_a, b_a)
    END IF
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      if (isrfl .EQ. -1) then
         r_a(nang, 1:nang) = 0.0
         DO j=1,nang
           fac = two*gmu(j)*gwt(j)
           DO i=1,nang
             rs_a = rs_a + fac*r_a(j, i)
             r_a(j, i) = 0.0
           END DO
         END DO
      else if (isrfl .EQ. 2) then
         DO j=1,nang
             rs_a = rs_a + r_a(j, j)
             r_a(j, 1:nang) = 0.0
         END DO
      end if
    END IF
    CALL POPINTEGER4(branch)
    IF (branch .LT. 1) THEN
      salb_a = salb_a + rs_a
!!$    ELSE
!!$      salb_a = 0.0
    END IF
  END IF
  em_a(:) = 0.0
  END SUBROUTINE SURFCE_A
!  Differentiation of clrlay in reverse (adjoint) mode:
!   gradient, with respect to input variables: tau tup empl emml
!                tlay ta
!   of linear combination of output variables: tau tup empl emml
!                tlay ta
!
  SUBROUTINE CLRLAY_A(tau, tau_a, ta, ta_a, tup, tup_a, reflg, ltyp, vn&
&    , tlay, tlay_a, empl, empl_a, emml, emml_a, linInTauFlag)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   CLRLAY
!
! PURPOSE:
!
!   Calculate transmission and emission for a clear slab.
!
! SYNTAX:
!
!   CALL CLRLAY(TAU, TA, TUP, REFLG, LTYP, VN)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   TAU    REAL(FP)     Optical depth
!   TA     REAL(FP)     Lower level temperature
!   TUP    REAL(FP)     Upper level temperature
!   REFLG  LOGICAL  Flag for calculating surface reflectance
!   LTYP   INTEGER  Identifier for clear/cloudy layers
!   VN     REAL(Double)   Wavenumber, units of cm^-1
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     This subroutine does the transmission and emission calculations
!     for a clear slab. The routine processes NLIM spectral points.
!     Transmission and forward and backward emission for each successive
!     clear layer are accumulated respectively in TLAY, EMPL and EMML.
!     If no thermal emission the routine accumulates the optical depths
!     in TLAY and calculates the transmission only when the last clear layer
!     of a series is reached. Linear-in-tau approximation is used for the
!     thermal source and it is assumed that the Planck function varies
!     linearly across the spectral interval spanned by the NLIM spectral
!     points.
!
!     REVISED:  11 OCTOBER 1993
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
    REAL(DOUBLE), INTENT(IN) :: vn
    INTEGER, INTENT(IN) :: ltyp
    LOGICAL, INTENT(IN) :: reflg
    LOGICAL                  :: linInTauFlag
    REAL(fp) :: ta, tup, tau
    REAL(fp) :: ta_a, tup_a, tau_a
    REAL(fp) :: tlay(:), empl(:), emml(:)
    REAL(fp) :: tlay_a(:), empl_a(:), emml_a(:)
!
    LOGICAL :: plnck, sbeam
    REAL(fp) :: ylm0
    REAL(fp) :: pth
    REAL(fp) :: ylm
    REAL(fp) :: gmu
    REAL(fp) :: gwt
    REAL(fp) :: gmu0
!
    COMMON /angl/ pth(mxang), gmu(mxang), gwt(mxang), gmu0, ylm(0:2*&
&    mxcang-1, mxang), ylm0(0:2*mxcang-1)
    save /angl/
    REAL(fp) :: cl2inv
    REAL(fp) :: pi
    COMMON /constn/ pi, cl2inv
    save /constn/
    COMMON /lpar/ plnck, sbeam
    save /lpar/
    INTEGER :: nang
    INTEGER :: nang2
    INTEGER :: n2ang
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    REAL(fp) :: tx
    REAL(fp) :: tx_a
    REAL(fp) :: emm
    REAL(fp) :: emm_a
    REAL(fp) :: emp
    REAL(fp) :: emp_a
    REAL(fp) :: wk
    REAL(fp) :: wk_a
    DIMENSION tx(mxang), emp(mxang), emm(mxang), wk(mxang)
    DIMENSION tx_a(mxang), emp_a(mxang), emm_a(mxang), wk_a(mxang)
    INTEGER :: i
    REAL(fp) :: ba
    REAL(fp) :: ba_a
    REAL(fp) :: bb
    REAL(fp) :: bb_a
    REAL(fp) :: bav
    REAL(fp) :: bav_a
    REAL(fp) :: delb
    REAL(fp) :: delb_a
    INTEGER :: n
    REAL(fp) :: em0
    REAL(fp) :: em0_a
    REAL(fp) :: cci
    REAL(fp) :: cci_a
    REAL(fp) :: emd
    REAL(fp) :: emd_a
    INTRINSIC EXP
    INTEGER :: branch
!
    ! initialize local adjoint variables
    tx_a=0.
    emm_a=0.
    emp_a=0.
    wk_a=0.
    ba_a=0.
    bb_a=0.
    bav_a=0.
    delb_a=0.
    em0_a=0.
    cci_a=0.
    emd_a=0.

!     Scale optical depths for all incident angles including observer
!     angle.
!
    DO i=1,nang
      wk(i) = tau*pth(i)
    END DO
!
! *** THERMAL CASE.
!
    IF (plnck) THEN
!
!     Calculate vertically averaged Planck function for the layer and
!     correction term for linear-in-Tau approximation at each spectral
!     point
!
      if (linInTauFlag) then
      ba = WNPLAN(vn, ta)
      bb = WNPLAN(vn, tup)
      bav = .5*(bb+ba)
      delb = .5*(bb-ba)
    else
!       Or omit linear in tau
        bav = wnplan(vn,(ta+tup)/two)
        delb = 0.
      end if

!
!     Compute transmittance and thermal emission
!
      DO n=1,nang
        tx(n) = EXP(-wk(n))
        CALL PUSHREALFP(em0)
        em0 = 1. - tx(n)
        IF (wk(n) .GT. 1.e-03) THEN
          CALL PUSHREALFP(cci)
          cci = two/wk(n)
          CALL PUSHREALFP(emd)
          emd = cci*(tx(n)-1.) + (tx(n)+1.)
          CALL PUSHINTEGER4(0)
        ELSE
          CALL PUSHREALFP(emd)
          emd = wk(n)*wk(n)*(1.-0.5*wk(n))/6.
          CALL PUSHINTEGER4(1)
        END IF
        emm(n) = em0*bav - emd*delb
      END DO
!
!     Accumulate partial results for clear slab.
!
      IF (ltyp .EQ. -1 .OR. ltyp .EQ. -100) THEN
! *** First layer
        IF (reflg) THEN
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        tx_a(:) = 0.0
        tx_a(1:nang) = tlay_a(1:nang)
        tlay_a(1:nang) = 0.0
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          emm_a(:) = 0.0
        ELSE
          emm_a(:) = 0.0
          emm_a(1:nang) = emml_a(1:nang)
          emml_a(1:nang) = 0.0
        END IF
        emp_a(:) = 0.0
        emp_a(1:nang) = empl_a(1:nang)
        empl_a(1:nang) = 0.0
        wk_a(:) = 0.0
      ELSE
! *** Update forward and backward emission for subsequent layers
        IF (reflg) THEN
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        tx_a(:) = 0.0
        tx_a(1:nang) = tlay(1:nang)*tlay_a(1:nang)
        tlay_a(1:nang) = tx(1:nang)*tlay_a(1:nang)
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          emm_a(:) = 0.0
          wk_a(:) = 0.0
        ELSE
          wk_a(:) = 0.0
          wk_a(1:nang) = emml_a(1:nang)
          emm_a(:) = 0.0
          tlay_a(1:nang) = tlay_a(1:nang) + emm(1:nang)*wk_a(1:nang)
          emm_a(1:nang) = tlay(1:nang)*wk_a(1:nang)
          wk_a(1:nang) = 0.0
        END IF
        emp_a(:) = 0.0
        wk_a(1:nang) = wk_a(1:nang) + empl_a(1:nang)
        emp_a(1:nang) = empl_a(1:nang)
        empl_a(1:nang) = tx(1:nang)*wk_a(1:nang)
        tx_a(1:nang) = tx_a(1:nang) + empl(1:nang)*wk_a(1:nang)
        wk_a(1:nang) = 0.0
      END IF
      bav_a = 0.0
      delb_a = 0.0
      DO n=nang,1,-1
        em0_a = bav*emp_a(n) + bav*emm_a(n)
        bav_a = bav_a + em0*emp_a(n) + em0*emm_a(n)
        emd_a = delb*emp_a(n) - delb*emm_a(n)
        delb_a = delb_a + emd*emp_a(n) - emd*emm_a(n)
        emm_a(n) = 0.0
        emp_a(n) = 0.0
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          CALL POPREALFP(emd)
          cci_a = (tx(n)-1.)*emd_a
          tx_a(n) = tx_a(n) + (cci+1.0)*emd_a
          CALL POPREALFP(cci)
          wk_a(n) = wk_a(n) - two*cci_a/wk(n)**2
        ELSE
          CALL POPREALFP(emd)
          wk_a(n) = wk_a(n) + ((1.-0.5*wk(n))*2*wk(n)/6.-wk(n)**2*0.5/6.&
&            )*emd_a
        END IF
        CALL POPREALFP(em0)
        tx_a(n) = tx_a(n) - em0_a
        wk_a(n) = wk_a(n) - EXP(-wk(n))*tx_a(n)
        tx_a(n) = 0.0
      END DO
      bb_a = .5*bav_a + .5*delb_a
      ba_a = .5*bav_a - .5*delb_a
      CALL WNPLAN_A0(vn, tup, tup_a, bb_a)
      CALL WNPLAN_A0(vn, ta, ta_a, ba_a)
    ELSE
!
! *** SOLAR ONLY
!
      IF (ltyp .EQ. -1 .OR. ltyp .EQ. -100) THEN
        CALL LOC_PUSHREAL4ARRAY(tlay(1:nang), fac_pp*nang)
        tlay(1:nang) = wk(1:nang)
        CALL PUSHINTEGER4(0)
      ELSE
        CALL LOC_PUSHREAL4ARRAY(tlay(1:nang), fac_pp*nang)
        tlay(1:nang) = wk(1:nang) + tlay(1:nang)
        CALL PUSHINTEGER4(1)
      END IF
!
! *** Compute transmittance for combined consecutive clear layers
!
      IF (ltyp .LE. -99) THEN
        DO n=nang,1,-1
          tlay_a(n) = -(EXP(-tlay(n))*tlay_a(n))
        END DO
      END IF
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        wk_a(:) = 0.0
        CALL LOC_POPREAL4ARRAY(tlay(1:nang), nang)
        wk_a(1:nang) = tlay_a(1:nang)
        tlay_a(1:nang) = 0.0
      ELSE
        wk_a(:) = 0.0
        CALL LOC_POPREAL4ARRAY(tlay(1:nang), nang)
        wk_a(1:nang) = tlay_a(1:nang)
      END IF
    END IF
    DO i=nang,1,-1
      tau_a = tau_a + pth(i)*wk_a(i)
      wk_a(i) = 0.0
    END DO
  END SUBROUTINE CLRLAY_A
!  Differentiation of mslay in reverse (adjoint) mode:
!   gradient, with respect to input variables: f0 tup alpha ssalb
!                text ta
!   of linear combination of output variables: f0 tup alpha empl
!                emml ssalb text tlay rlay ta
!
  SUBROUTINE MSLAY_A(text, text_a, ssalb, ssalb_a, ta, ta_a, tup, tup_a&
&    , f0, f0_a, rlay, rlay_a, tlay, tlay_a, empl, empl_a, emml, emml_a, &
&    maz, vn, alpha, alpha_a, mrgup, linInTauFlag)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   MSLAY
!
! PURPOSE:
!
!   Apply doubling tables for a cloudy layer. Compute forward and backward
!   internal emission due to thermal and solar sources.
!
! SYNTAX:
!
!   CALL MSLAY(TEXT, SSALB, TA, TUP, F0, RLAY, TLAY, EMPL, EMML, MAZ,
!      VN, ALPHA, MRGUP)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   TEXT   REAL(FP)     Total extinction
!   SSALB  REAL(FP)     Albedo
!   TA     REAL(FP)     Lower level temperature
!   TUP    REAL(FP)     Upper level temperature
!   F0     REAL(FP)     solar irradiance at top of scattering layer
!   MAZ    INTEGER  Index for azimuthal direction in scattering calculations
!   VN     REAL(Double)   Wavenumber, units of cm^-1
!   ALPHA  REAL(FP)     Phase function
!   MRGUP  INTEGER  Flag for down/upward calculations
!
!   INPUTS/OUTPUTS:
!
!   RLAY   REAL(FP)     Layer refrection
!   TLAY   REAL(FP)     Layer transmission
!   EMPL   REAL(FP)     Forward emission
!   EMML   REAL(FP)     Backward emission
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     This subroutine does the interpolation of the doubling results
!     for a cloudy layer. The routine processes NLIM spectral points.
!     Reflection, transmission and forward and backward emission are output
!     respectively in RLAY, TLAY, EMPL and EMML. Linear-in-tau approximation
!     is used for the thermal source and it is assumed that the Planck
!     function varies linearly across the spectral interval spanned by the
!     NLIM spectral points.
!
!     LAST REVISED: MARCH 1995 to implement linear spectral interpolation
!                   of the doubling results.
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
    LOGICAL                  :: linInTauFlag
    REAL(fp), DIMENSION(0:2*mxcang) :: alpha
    REAL(fp), DIMENSION(0:2*mxcang) :: alpha_a
    INTEGER, INTENT(IN) :: mrgup, maz
    INTEGER :: nang2
    REAL(fp), DIMENSION(nang2) :: rlay, tlay
    REAL(fp), DIMENSION(nang2) :: rlay_a, tlay_a
    INTEGER :: nang
    REAL(fp), DIMENSION(nang) :: empl, emml
    REAL(fp), DIMENSION(nang) :: empl_a, emml_a
    REAL(fp) :: text, ssalb
    REAL(fp) :: text_a, ssalb_a
    REAL(fp) :: ta, tup, f0
    REAL(fp) :: ta_a, tup_a, f0_a
    REAL(DOUBLE), INTENT(IN) :: vn
!
    REAL(fp) :: em(2*mxang), sbm(2*mxang)
    REAL(fp) :: em_a(2*mxang), sbm_a(2*mxang)
    LOGICAL :: plnck, sbeam
!
    COMMON /lpar/ plnck, sbeam
    save /lpar/
    INTEGER :: n2ang
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    REAL(fp) :: ba
    REAL(fp) :: ba_a
    REAL(fp) :: bb
    REAL(fp) :: bb_a
    REAL(fp) :: bav
    REAL(fp) :: bav_a
    REAL(fp) :: delb
    REAL(fp) :: delb_a
    INTEGER :: n
    INTEGER :: branch
!
    ! initialize local adjoint variables
    em_a=0.
    sbm_a=0.
    ba_a=0.
    bb_a=0.
    bav_a=0.
    delb_a=0.
!
!
    IF (plnck) THEN
      if (linInTauFlag) then
      ba = WNPLAN(vn, ta)
      bb = WNPLAN(vn, tup)
      bav = .5*(bb+ba)
      delb = .5*(bb-ba)
    else
!       Or omit linear in tau
        bav = wnplan(vn,(ta+tup)/two)
        delb = 0.
      end if
    END IF
!!$    CALL PUSHREAL4ARRAY(sbm, 2*fac_pp*mxang) ! is initialized in gentab call, uninitialized before that
!!$    CALL PUSHREAL4ARRAY(em, 2*fac_pp*mxang)
    CALL LOC_PUSHREAL4ARRAY(tlay, fac_pp*nang2)
    CALL LOC_PUSHREAL4ARRAY(rlay, fac_pp*nang2)
!
!     Get doubling tables for current cloud layer
!
!CALL GENTAB(TABS,TSCAT,ALPHA,MAZ,RLAY,TLAY,EM,SBM)
    CALL GENTAB(text, ssalb, alpha, maz, rlay, tlay, em, sbm)
!
!     Compute forward and backward internal emission due to
!     thermal and solar sources
!
!     ! Omitted from NLM recomputation: (NLM not needed)
!        Calculate vertically averaged Planck function...; Add solar component
    IF (sbeam) THEN
!
!     Add solar component
!
      IF (mrgup .EQ. 1) THEN
        sbm_a(1:2*mxang) = 0.0
        DO n=nang,1,-1
          sbm_a(nang+n) = sbm_a(nang+n) + f0*emml_a(n)
          f0_a = f0_a + sbm(n)*empl_a(n) + sbm(nang+n)*emml_a(n)
          sbm_a(n) = sbm_a(n) + f0*empl_a(n)
        END DO
      ELSE
        sbm_a(1:2*mxang) = 0.0
        DO n=nang,1,-1
          sbm_a(n) = sbm_a(n) + f0*emml_a(n)
          f0_a = f0_a + sbm(nang+n)*empl_a(n) + sbm(n)*emml_a(n)
          sbm_a(nang+n) = sbm_a(nang+n) + f0*empl_a(n)
        END DO
      END IF
    ELSE
      sbm_a(1:2*mxang) = 0.0
    END IF
    IF (.not. plnck) THEN
      bav_a = 0.0
      delb_a = 0.0
      em_a(1:2*mxang) = 0.0
    ELSE
      bav_a = 0.0
      delb_a = 0.0
      em_a(1:2*mxang) = 0.0
      DO n=nang,1,-1
        em_a(n) = em_a(n) + bav*emml_a(n)
        bav_a = bav_a + em(n)*empl_a(n) + em(n)*emml_a(n)
        em_a(nang+n) = em_a(nang+n) - delb*emml_a(n)
        delb_a = delb_a + em(nang+n)*empl_a(n) - em(nang+n)*emml_a(n)
        emml_a(n) = 0.0
        em_a(n) = em_a(n) + bav*empl_a(n)
        em_a(nang+n) = em_a(nang+n) + delb*empl_a(n)
        empl_a(n) = 0.0
      END DO
    END IF
    CALL LOC_POPREAL4ARRAY(rlay, fac_pp*nang2)
    CALL LOC_POPREAL4ARRAY(tlay, fac_pp*nang2)
!!$    CALL POPREAL4ARRAY(em, 2*fac_pp*mxang)
!!$    CALL POPREAL4ARRAY(sbm, 2*fac_pp*mxang)
    CALL GENTAB_A(text, text_a, ssalb, ssalb_a, alpha, alpha_a, maz, &
&            rlay, rlay_a, tlay, tlay_a, em, em_a, sbm, sbm_a)
    tlay_a = 0.0
    IF (plnck) THEN
      bb_a = .5*bav_a + .5*delb_a
      ba_a = .5*bav_a - .5*delb_a
      CALL WNPLAN_A0(vn, tup, tup_a, bb_a)
      CALL WNPLAN_A0(vn, ta, ta_a, ba_a)
    END IF
  END SUBROUTINE MSLAY_A
!  Differentiation of gentab in reverse (adjoint) mode:
!   gradient, with respect to input variables: gmu0 ylm pi alpha
!                ssalb text
!   of linear combination of output variables: r alpha em ssalb
!                text sbm trnsm
!
  SUBROUTINE GENTAB_A(text, text_a, ssalb, ssalb_a, alpha, alpha_a, maz&
&    , r, r_a, trnsm, trnsm_a, em, em_a, sbm, sbm_a)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   GENTAB
!
! PURPOSE:
!
!   Generate look-up tables of reflection, transmission matrices and source
!   vectors by doubling calculations.
!
! SYNTAX:
!
!   CALL GENTAB(TEXT, SSALB, ALPHA, MAZ, R, TRNSM, EM, SBM)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   TEXT   REAL(FP)     Total extinction
!   SSALB  REAL(FP)     Albedo
!   ALPHA  REAL(FP)     Phase function
!   MAZ    INTEGER  Index for azimuthal direction in scattering calculations
!
!   INPUTS/OUTPUTS:
!
!   R      REAL(FP)     Reflection matrix at NBOT0/NBOT
!   TRNSM  REAL(FP)     Transmission matrix at NBOT0/NBOT
!   EM     REAL(FP)     Emission vector at NBOT0/NBOT
!   SBM    REAL(FP)     upward and downward emission due to solar scattering
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     Generate look up tables of reflexion, transmission matrices
!     and source vectors by doubling calculations for the range of
!     absorption optical depths specified by NMIN and NMAX. NMIN0
!     and NMAX0 indicate the range of the calculations covered in
!     previous calls to GENTAB so that calculations corresponding
!     to NMIN0<N<NMAX0 do not have to be redone. Table entries are
!     in the common block /TABX/.
!
!     NOTE:
!     Internal sources due to thermal emission and solar scattering
!     are stored in vectors EM and SBM respectively. The first NANG
!     elements of SBM correspond to the reflected solar radiation,
!     while the second NANG elements correspond to the transmitted
!     solar radiation. For the thermal sources, the first NANG elements
!     contain the emission for an isothermal layer which is the same
!     in the downward and upward directions. The second set of elements
!     are correction terms which account for the assumed linear-in-tau
!     dependence of the PLanck function within the layer. Upward and
!     downward thermal sources are derived in the subroutine MSLAY by
!     respectively adding and subtracting the correction terms from the
!     first set of elements.
!
!     REVISED:  21 MARCH 1995
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
    REAL(fp), DIMENSION(0:2*mxcang) :: alpha
    REAL(fp), DIMENSION(0:2*mxcang) :: alpha_a
    REAL(fp) :: text, ssalb
    REAL(fp) :: text_a, ssalb_a
    INTEGER, INTENT(IN) :: maz
    INTEGER :: nang2
    REAL(fp), DIMENSION(nang2) :: r, trnsm
    REAL(fp), DIMENSION(nang2) :: r_a, trnsm_a
    INTEGER :: n2ang
    REAL(fp), DIMENSION(n2ang) :: em, sbm
    REAL(fp), DIMENSION(n2ang) :: em_a, sbm_a
!
    REAL(fp) :: pfp(mxang2), pfm(mxang2), pfp0(mxang), pfm0(mxang)
    REAL(fp) :: pfp_a(mxang2), pfm_a(mxang2), pfp0_a(mxang), pfm0_a(&
&    mxang)
    LOGICAL :: plnck, sbeam
    REAL(fp) :: ylm0
    REAL(fp) :: pth
    REAL(fp) :: ylm
    REAL(fp) :: gmu
    REAL(fp) :: gwt
    REAL(fp) :: gmu0
!
    COMMON /angl/ pth(mxang), gmu(mxang), gwt(mxang), gmu0, ylm(0:2*&
&    mxcang-1, mxang), ylm0(0:2*mxcang-1)
    save /angl/
    COMMON /lpar/ plnck, sbeam
    save /lpar/
    INTEGER :: nang
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    REAL(fp) :: cl2inv
    REAL(fp) :: pi
    COMMON /constn/ pi, cl2inv
    save /constn/
    INTEGER :: i
    INTEGER :: j
    INTEGER :: ij
    REAL(fp) :: sgn
    INTEGER :: l
    REAL(fp) :: pij
    REAL(fp) :: pij_a
    REAL(fp) :: scal
    REAL(fp) :: pi0
    REAL(fp) :: pi0_a
    REAL(fp) :: exp2
    INTEGER :: nit
    REAL(fp) :: dtau
    REAL(fp) :: dtau_a
    REAL(fp) :: att
    REAL(fp) :: att_a
    REAL(fp) :: pwr1
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC LOG
    INTRINSIC INT
    INTEGER :: y1
    INTEGER :: branch
!
    ! initialize local adjoint variables
    pfp_a=0.
    pfm_a=0.
    pfp0_a=0.
    pfm0_a=0.
    pij_a=0.
    pi0_a=0.
    dtau_a=0.
    att_a=0.
! *** Construct phase matrix.
! *** Pre-scale matrices for diamond initialization (DI) and apply
! *** angular weighting.
!
    DO i=1,nang
      DO j=1,nang-1
        ij = (i-1)*nang + j
        pfp(ij) = 0.
        pfm(ij) = 0.
        sgn = 1.
        DO l=maz,n2ang-3
          pij = alpha(l)*ylm(l, i)*ylm(l, j)
          pfp(ij) = pfp(ij) + pij
          pfm(ij) = pfm(ij) + sgn*pij
          CALL PUSHREALFP(sgn)
          sgn = -sgn
        END DO
        pfp(ij) = -(0.25*pfp(ij)*pth(i)*gwt(j))
        pfm(ij) = 0.25*pfm(ij)*pth(i)*gwt(j)
      END DO
! *** Observer angle
      pfp(ij+1) = 0.
      pfm(ij+1) = 0.
    END DO
!
! *** Construct phase matrix for solar source.
!
    IF (sbeam) THEN
      IF (maz .EQ. 0) THEN
        scal = .25*gmu0
      ELSE
        scal = .5*gmu0
      END IF
!
      DO i=1,nang
        pfp0(i) = 0.
        pfm0(i) = 0.
        sgn = 1.
        DO l=maz,n2ang-3
          pi0 = alpha(l)*ylm(l, i)*ylm0(l)
          pfp0(i) = pfp0(i) + pi0
          pfm0(i) = pfm0(i) + sgn*pi0
          CALL PUSHREALFP(sgn)
          sgn = -sgn
        END DO
        pfp0(i) = scal*pfp0(i)*pth(i)
        pfm0(i) = scal*pfm0(i)*pth(i)
      END DO
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
!
! *** Use DI approximation when layer extinction optical depth
! *** is less than 2**-10.
!
!      TEXT=TABS+TSCAT
!      SSALB=TSCAT/TEXT
! *** Compute initial layer optical depth and number of doublings
! *** necessary to reach TEXT
    exp2 = LOG(text)*cl2inv
    IF (exp2 .LT. -30.) THEN
      exp2 = -30.
    ELSE
      exp2 = exp2
    END IF
    y1 = INT(exp2 + 4.)
    IF (0 .LT. y1) THEN
      nit = y1
    ELSE
      nit = 0
    END IF
    pwr1 = two**nit
    dtau = text/pwr1
    IF (sbeam) THEN
      att = EXP(-(dtau/gmu0))
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    CALL LOC_PUSHREAL4ARRAY(trnsm, fac_pp*nang2)
    CALL LOC_PUSHREAL4ARRAY(r, fac_pp*nang2)
! *** Initialize doubling calculations
    CALL DI(dtau, ssalb, pfp, pfm, pfp0, pfm0, r, trnsm, em, sbm)
!
    CALL DOUBL_A(nit, att, att_a, r, r_a, trnsm, trnsm_a, em, em_a, sbm&
&           , sbm_a)
    CALL LOC_POPREAL4ARRAY(r, fac_pp*nang2)
    CALL LOC_POPREAL4ARRAY(trnsm, fac_pp*nang2)
    CALL DI_A(dtau, dtau_a, ssalb, ssalb_a, pfp, pfp_a, pfm, pfm_a, pfp0&
&        , pfp0_a, pfm0, pfm0_a, r, r_a, trnsm, trnsm_a, em, em_a, sbm, &
&        sbm_a)
    trnsm_a = 0.0
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) dtau_a = dtau_a - EXP(-(dtau/gmu0))*att_a/&
&        gmu0
    text_a = text_a + dtau_a/pwr1
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      DO i=nang,1,-1
        pfm0_a(i) = scal*pth(i)*pfm0_a(i)
        pfp0_a(i) = scal*pth(i)*pfp0_a(i)
        DO l=n2ang-3,maz,-1
          CALL POPREALFP(sgn)
          pi0_a = pfp0_a(i) + sgn*pfm0_a(i)
          alpha_a(l) = alpha_a(l) + ylm(l, i)*ylm0(l)*pi0_a
        END DO
        pfm0_a(i) = 0.0
        pfp0_a(i) = 0.0
      END DO
    END IF
    DO i=nang,1,-1
      ij=(i-1)*nang+nang-1
      pfm_a(ij+1) = 0.0
      pfp_a(ij+1) = 0.0
      DO j=nang-1,1,-1
        ij = (i-1)*nang + j
        pfm_a(ij) = pth(i)*0.25*gwt(j)*pfm_a(ij)
        pfp_a(ij) = -(pth(i)*0.25*gwt(j)*pfp_a(ij))
        DO l=n2ang-3,maz,-1
          CALL POPREALFP(sgn)
          pij_a = pfp_a(ij) + sgn*pfm_a(ij)
          alpha_a(l) = alpha_a(l) + ylm(l, j)*ylm(l, i)*pij_a
        END DO
        pfm_a(ij) = 0.0
        pfp_a(ij) = 0.0
      END DO
    END DO
  END SUBROUTINE GENTAB_A
!  Differentiation of di in reverse (adjoint) mode:
!   gradient, with respect to input variables: pfm pfp pfp0 pfm0
!                ssalb deltau
!   of linear combination of output variables: r em ssalb sbm trnsm
!
  SUBROUTINE DI_A(deltau, deltau_a, ssalb, ssalb_a, pfp, pfp_a, pfm, &
&    pfm_a, pfp0, pfp0_a, pfm0, pfm0_a, r, r_a, trnsm, trnsm_a, em, em_a&
&    , sbm, sbm_a)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   DI
!
! PURPOSE:
!
!   Calculate reflection, transmission and sources for an infinitesimal layer by
!   using the Diamond Initialization scheme.
!
! SYNTAX:
!
!   CALL DI(DELTAU, SSALB, PFP, PFM, PFP0, PFM0, R, TRNSM, EM, SBM)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   DELTAU  REAL(FP)  TBD
!   SSALB   REAL(FP)  Albedo
!
!   INPUTS/OUTPUTS:
!
!   PFP     REAL(FP)  Phase matrix
!   PFM     REAL(FP)  Phase matrix
!   PFP0    REAL(FP)  Phase matrix for solar source
!   PFM0    REAL(FP)  Phase matrix for solar source
!   R       REAL(FP)  Reflection matrix at NBOT0/NBOT
!   TRNSM   REAL(FP)  Transmission matrix at NBOT0/NBOT
!   EM      REAL(FP)  Emission vector at NBOT0/NBOT
!   SBM     REAL(FP)  upward and downward emission due to solar scattering
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     This routine calculates reflection, transmission and sources for
!     an infinitesimal layer using the Diamond Initialization scheme.
!     (for the treatment of the thermal emission, see note above in
!     subroutine GENTAB)
!
!     REF: Wiscombe,1976, JQSRT, pp637-658.
!
!     REVISED:  04 OCTOBER 1993
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
    REAL(fp) :: deltau, ssalb
    REAL(fp) :: deltau_a, ssalb_a
    INTEGER :: nang
    REAL(fp), DIMENSION(nang, nang) :: r, trnsm
    REAL(fp), DIMENSION(nang, nang) :: r_a, trnsm_a
    REAL(fp), DIMENSION(nang, 2) :: em, sbm
    REAL(fp), DIMENSION(nang, 2) :: em_a, sbm_a
    REAL(fp), DIMENSION(nang, nang) :: pfp, pfm
    REAL(fp), DIMENSION(nang, nang) :: pfp_a, pfm_a
    REAL(fp), DIMENSION(nang) :: pfp0, pfm0
    REAL(fp), DIMENSION(nang) :: pfp0_a, pfm0_a
    LOGICAL :: plnck, sbeam
    REAL(fp) :: ylm0
    REAL(fp) :: pth
    REAL(fp) :: ylm
    REAL(fp) :: gmu
    REAL(fp) :: gwt
    REAL(fp) :: gmu0
!
    COMMON /angl/ pth(mxang), gmu(mxang), gwt(mxang), gmu0, ylm(0:2*&
&    mxcang-1, mxang), ylm0(0:2*mxcang-1)
    save /angl/
    REAL(fp) :: cl2inv
    REAL(fp) :: pi
    COMMON /constn/ pi, cl2inv
    save /constn/
    COMMON /lpar/ plnck, sbeam
    save /lpar/
    INTEGER :: nang2
    INTEGER :: n2ang
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    REAL(fp) :: ti
    REAL(fp) :: ti_a
    REAL(fp) :: gamma
    REAL(fp) :: gamma_a
    REAL(fp) :: rtinv
    REAL(fp) :: rtinv_a
    REAL(fp) :: tinv
    REAL(fp) :: tinv_a
    REAL(fp) :: wkem
    REAL(fp) :: wkem_a
    REAL(fp) :: wk
    REAL(fp) :: wk_a
    REAL(fp) :: wksbm
    REAL(fp) :: wksbm_a
    DIMENSION gamma(mxang2), ti(mxang2), tinv(mxang2), rtinv(mxang2), wk&
&        (mxang2), wkem(mxang), wksbm(2*mxang)
    DIMENSION gamma_a(mxang2), ti_a(mxang2), tinv_a(mxang2), rtinv_a(&
&        mxang2), wk_a(mxang2), wkem_a(mxang), wksbm_a(2*mxang)
    REAL(fp) :: c1
    REAL(fp) :: c1_a
    REAL(fp) :: c2
    REAL(fp) :: c2_a
    INTEGER :: i
    INTEGER :: ii
!!$    REAL(FP) :: det
    REAL(fp) :: cem
    REAL(fp) :: cem_a
    INTEGER :: j
    INTEGER :: ij
    REAL(fp) :: csol
    REAL(fp) :: csol_a
    INTRINSIC EXP
    INTEGER :: ierr
    INTEGER :: branch
    integer, parameter :: max_vec=2+4*mxang2+6*mxang
    real (fp) :: save_nlm(max_vec)
!
    ! initialize local adjoint variables
    ti_a=0.
    gamma_a=0.
    rtinv_a=0.
    tinv_a=0.
    wkem_a=0.
    wk_a=0.
    wksbm_a=0.
    c1_a=0.
    c2_a=0.
    cem_a=0.
    csol_a=0.
!
    c1 = deltau*ssalb
    c2 = 0.5*deltau
    ti(1:nang2) = reshape(pfp(:,:) * c1,(/nang2/))
    r(:,:) = pfm(:,:) * c1
    DO i=1,nang
!!$      CALL PUSHINTEGER4(ii)
      ii = (i-1)*nang + i
      ti(ii) = ti(ii) + pth(i)*c2 + 1.
    END DO
!
!     Build Gamma matrix - scale by a factor 2
!
    tinv(1:nang2) = ti(1:nang2)
    CALL LOC_PUSHREAL4ARRAY(tinv, fac_pp*mxang2)
!$    CALL sMINV(TINV,NANG,NANG,WK,DET,TOL,0,1)
    CALL SMINV(tinv, nang, ierr)
    CALL MXM(tinv, nang, r, nang, rtinv, nang)
    CALL MXM(r, nang, rtinv, nang, wk, nang)
    gamma(1:nang2) = ti(1:nang2) - wk(1:nang2)
    CALL LOC_PUSHREAL4ARRAY(gamma, fac_pp*mxang2)
!$    CALL sMINV(GAMMA,NANG,NANG,WK,DET,TOL,0,1)
    CALL SMINV(gamma, nang, ierr)
    gamma(1:nang2) = gamma(1:nang2)*two
    CALL LOC_PUSHREAL4ARRAY(r, fac_pp*nang*nang)
!
!     Compute reflection matrix
!
    CALL MXM(rtinv, nang, gamma, nang, r, nang)
!
!     Compute transmission matrix (omitted because not used in TLM/adjoint computations)
!
!
!     Compute thermal emission terms
!
    IF (plnck) THEN
      cem = (deltau-c1)*0.5 !manually added
      wkem(1:nang) = pth(1:nang)*cem  !manually added
      wk(1:nang2) = gamma(1:nang2) + reshape(r(:,:),(/nang2/))
!        CALL MXV(WK,NANG,WKEM,NANG,EM)
!!$      DO i=1,nang
!!$        DO j=1,nang
!!$          CALL PUSHINTEGER4(ij)
!!$          ij = (i-1)*nang + j
!!$        END DO
!!$      END DO
!!$      CALL PUSHINTEGER4(1)
    ELSE
!!$      CALL PUSHINTEGER4(0)
    END IF
!
!     Compute upward and downward emission due to solar scattering
!
    IF (sbeam) THEN
      csol = .5*ssalb/pi*(1.-EXP(-(deltau/gmu0)))
      wksbm(1:nang) = pfm0(1:nang)*csol
      wksbm(nang+1:2*nang) = pfp0(1:nang)*csol
!!$      DO i=1,nang
!!$        DO j=1,nang
!!$          CALL PUSHINTEGER4(ij)
!!$          ij = (i-1)*nang + j
!!$        END DO
!!$      END DO
      gamma_a(1:mxang2) = 0.0
      wksbm_a(:) = 0.0
      DO i=nang,1,-1
        DO j=nang,1,-1
          ij=(i-1)*nang+j
          gamma_a(ij) = gamma_a(ij) + wksbm(j)*sbm_a(i, 1) + wksbm(nang+&
&            j)*sbm_a(i, 2)
          wksbm_a(nang+j) = wksbm_a(nang+j) + gamma(ij)*sbm_a(i, 2)
          r_a(j, i) = r_a(j, i) + wksbm(nang+j)*sbm_a(i, 1) + wksbm(j)*&
&            sbm_a(i, 2)
          wksbm_a(j) = wksbm_a(j) + gamma(ij)*sbm_a(i, 1) + r(j, i)*&
&            sbm_a(i, 2)
          wksbm_a(nang+j) = wksbm_a(nang+j) + r(j, i)*sbm_a(i, 1)
!!$          CALL POPINTEGER4(ij)
        END DO
        sbm_a(i, 2) = 0.0
        sbm_a(i, 1) = 0.0
      END DO
      pfp0_a(:) = 0.0
      pfp0_a(1:nang) = csol*wksbm_a(nang+1:2*nang)
      csol_a = SUM(pfp0(1:nang)*wksbm_a(nang+1:2*nang))
      wksbm_a(nang+1:2*nang) = 0.0
      pfm0_a(:) = 0.0
      pfm0_a(1:nang) = csol*wksbm_a(1:nang)
      csol_a = csol_a + SUM(pfm0(1:nang)*wksbm_a(1:nang))
      deltau_a = .5*ssalb*EXP(-(deltau/gmu0))*csol_a/(pi*gmu0)
      ssalb_a = ssalb_a + .5*(1.-EXP(-(deltau/gmu0)))*csol_a/pi
    ELSE
!!$      pfp0_a(:) = 0.0  !manually deleted
!!$      pfm0_a(:) = 0.0
!!$      deltau_a = 0.0
!!$      gamma_a(1:mxang2) = 0.0
    END IF
!!$    CALL POPINTEGER4(branch)
    IF (.not. plnck) THEN
      wk_a(1:mxang2) = 0.0 !??not: c1_a=0
    ELSE
      em_a(:, 2) = 0.0
      wkem_a(:)=0.
      wk_a(1:mxang2) = 0.0 !??not: wkem_a(:)=0
      DO i=nang,1,-1
        DO j=nang,1,-1
          ij = (i-1)*nang + j
          wk_a(ij) = wk_a(ij) + wkem(j)*em_a(i, 1) !manually added
          wkem_a(j) = wkem_a(j) + wk(ij)*em_a(i, 1)
!!$          CALL POPINTEGER4(ij)
        END DO
        em_a(i, 1) = 0.0
      END DO
! missing:
!      CALL SVADD_A(gamma, gamma_a, r, r_a, wk, wk_a, nang2)
      gamma_a(:)=gamma_a(:) + wk_a(:) !manually added
      r_a(:,:)=r_a(:,:) + reshape(wk_a(:),(/nang,nang/))         !manually added
      wk_a(1:mxang2) = 0.0
      cem_a = SUM(pth(1:nang)*wkem_a(1:nang))
      deltau_a = deltau_a + 0.5*cem_a
      c1_a = -(0.5*cem_a)
    END IF
    gamma_a(1:nang2) = gamma_a(1:nang2) + reshape(trnsm_a(:,:),(/nang2/))
    trnsm_a(:,:) = 0.0
    CALL LOC_POPREAL4ARRAY(r, fac_pp*nang*nang)
    rtinv_a(:) = 0.0
    CALL MXM_A(rtinv, rtinv_a, nang, gamma, gamma_a, nang, r, r_a, nang)
    r_a(:,:) = 0.0 !R was reused
    gamma_a(1:nang2) = two*gamma_a(1:nang2)
    CALL LOC_POPREAL4ARRAY(gamma, fac_pp*mxang2)
    CALL SMINV_A(gamma, gamma_a, nang, ierr)
    ti_a(1:mxang2) = 0.0
    ti_a(1:nang2) = ti_a(1:nang2) + gamma_a(1:nang2) !manually added
    wk_a(1:mxang2) = 0.0
    wk_a(1:nang2) = wk_a(1:nang2) - gamma_a(1:nang2)
    CALL MXM_A(r, r_a, nang, rtinv, rtinv_a, nang, wk, wk_a, nang)
    tinv_a(:) = 0.0
    CALL MXM_A(tinv, tinv_a, nang, r, r_a, nang, rtinv, rtinv_a, nang)
    CALL LOC_POPREAL4ARRAY(tinv, fac_pp*mxang2)
    CALL SMINV_A(tinv, tinv_a, nang, ierr)
    ti_a(1:nang2) = tinv_a(1:nang2) + gamma_a(1:nang2)
    c2_a = 0.0
    DO i=nang,1,-1
      ii = (i-1)*nang + i
      c2_a = c2_a + pth(i)*ti_a(ii)
!!$      CALL POPINTEGER4(ii)
    END DO
!!$    pfm_a(:, :) = 0.0 !manually changed
    pfm_a(:,:) = pfm_a(:,:) + c1*r_a(:,:) !manually changed
    c1_a = c1_a + SUM(reshape(pfp(:,:),(/nang2/))*ti_a(1:nang2)) + SUM(pfm(:,:)*&
         r_a(:,:))
    r_a(:,:) = 0.0
!!$    pfp_a(:, :) = 0.0 !manually changed
    pfp_a(:,:) = pfp_a(:,:) + c1*reshape(ti_a(1:nang2),(/nang,nang/)) !manually changed
    deltau_a = deltau_a + ssalb*c1_a + 0.5*c2_a
    ssalb_a = ssalb_a + deltau*c1_a
  END SUBROUTINE DI_A
!  Differentiation of doubl in reverse (adjoint) mode:
!   gradient, with respect to input variables: r att em sbm trnsm
!   of linear combination of output variables: r em sbm trnsm
!
  SUBROUTINE DOUBL_A(nit, att, att_a, r, r_a, trnsm, trnsm_a, em, em_a, &
&    sbm, sbm_a)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   DOUBL
!
! PURPOSE:
!
!   Perform doubling calculations for a homogeneous scattering layer.
!
! SYNTAX:
!
!   CALL DOUBL(NIT, ATT, R, TRNSM, EM, SBM)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   NIT    INTEGER  number of doubling calculations
!
!   INPUTS/OUTPUTS:
!
!   ATT    REAL(FP)     TBD
!   R      REAL(FP)     Reflection matrix at NBOT0/NBOT
!   TRNSM  REAL(FP)     Transmission matrix at NBOT0/NBOT
!   EM     REAL(FP)     Emission vector at NBOT0/NBOT
!   SBM    REAL(FP)     upward and downward emission due to solar scattering
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     This subroutine does the doubling calculations for a homogeneous
!     scattering layer. The number of calculations is specified by NIT.
!     It is assumed that the reflection and transmission matrices and the
!     source vectors have already been initialized.
!
!     REVISED:  21 MARCH 1995
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
    INTEGER, INTENT(IN) :: nit
    REAL(fp) :: att
    REAL(fp) :: att_a
    INTEGER :: nang2
    REAL(fp), DIMENSION(nang2) :: r, trnsm
    REAL(fp), DIMENSION(nang2) :: r_a, trnsm_a
    INTEGER :: n2ang
    REAL(fp), DIMENSION(n2ang) :: em, sbm
    REAL(fp), DIMENSION(n2ang) :: em_a, sbm_a
!
    LOGICAL :: plnck, sbeam
!
    COMMON /lpar/ plnck, sbeam
    save /lpar/
    INTEGER :: nang
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    REAL(fp) :: wk1
    REAL(fp) :: wk1_a
    REAL(fp) :: wk2
    REAL(fp) :: wk2_a
    REAL(fp) :: wk3(mxang2)
    REAL(fp) :: wk3_a(mxang2)
    REAL(fp) :: rm
    REAL(fp) :: rm_a
    REAL(fp) :: wkt
    REAL(fp) :: wkt_a
    DIMENSION rm(mxang2), wk1(mxang2), wk2(mxang2), wkt(mxang2)
    DIMENSION rm_a(mxang2), wk1_a(mxang2), wk2_a(mxang2), wkt_a(mxang2)
    INTEGER :: n
    INTEGER :: i
!!$    REAL(FP) :: det
    INTEGER :: ierr
    INTEGER :: branch
!
    ! Initialize local adjoint variables
    wk1_a=0.
    wk2_a=0.
    wk3_a=0.
    rm_a=0.
    wkt_a=0.

    DO n=1,nit
!
!     Compute multiple reflection term
!
      CALL MXM(r, nang, r, nang, rm, nang)
      CALL LOC_PUSHREAL4ARRAY(rm, fac_pp*mxang2)   !pp_1
      DO i=1,nang2
        rm(i) = -rm(i)
      END DO
      DO i=1,nang2,nang+1
        rm(i) = rm(i) + 1.
      END DO
      CALL LOC_PUSHREAL4ARRAY(rm, fac_pp*mxang2)   !pp_2
!$       CALL sMINV(RM,NANG,NANG,WK1,DET,TOL,0,1)
      CALL SMINV(rm, nang, ierr)
      CALL LOC_PUSHREAL4ARRAY(rm, fac_pp*mxang2)   !pp_2a
!
!     Compute new transmission matrix
!
      CALL MXM(rm, nang, trnsm, nang, wk1, nang)
      CALL LOC_PUSHREAL4ARRAY(wkt, fac_pp*mxang2) !pp_3
      wkt(1:nang2) = trnsm(1:nang2)
      CALL LOC_PUSHREAL4ARRAY(trnsm, fac_pp*nang2) !pp_4
      CALL LOC_PUSHREAL4ARRAY(wk2, fac_pp*mxang2) !pp_5
      CALL MXM(wkt, nang, wk1, nang, trnsm, nang)
!
!     Double thermal and solar sources
!
      CALL MXM(r, nang, wk1, nang, wk2, nang)
      IF (plnck) THEN
        CALL LOC_PUSHREAL4ARRAY(em, fac_pp*n2ang) !pp_6
        CALL EMIS(em, wk1, wk2)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      IF (sbeam) THEN
        CALL PUSHREALFP(att)                  !pp_7
        CALL LOC_PUSHREAL4ARRAY(sbm, fac_pp*n2ang)
        CALL SUNB(sbm, wk1, wk2, att)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL LOC_PUSHREAL4ARRAY(wk1, fac_pp*mxang2)
!
!     Compute new reflection matrix
!
      CALL MXM(wkt, nang, wk2, nang, wk1, nang)
      CALL LOC_PUSHREAL4ARRAY(r, fac_pp*nang2)
      r(1:nang2) = r(1:nang2) + wk1(1:nang2)
    END DO
    wk1_a(1:mxang2) = 0.0
    wk2_a(1:mxang2) = 0.0
    rm_a(1:mxang2) = 0.0
    wkt_a(1:mxang2) = 0.0
    DO n=nit,1,-1
      CALL LOC_POPREAL4ARRAY(r, fac_pp*nang2)
      CALL LOC_POPREAL4ARRAY(wk1, fac_pp*mxang2)
      wk1_a(1:nang2) = wk1_a(1:nang2) + r_a(1:nang2)
      CALL MXM_A(wkt, wkt_a, nang, wk2, wk2_a, nang, wk1, wk1_a, nang)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN !sbeam
        CALL LOC_POPREAL4ARRAY(sbm, fac_pp*n2ang)  !pp_7
        CALL POPREALFP(att)
        CALL SUNB_A(sbm, sbm_a, wk1, wk1_a, wk2, wk2_a, att, att_a)
      END IF
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN !plnck
        CALL LOC_POPREAL4ARRAY(em, fac_pp*n2ang)  !pp_6
        CALL EMIS_A(em, em_a, wk1, wk1_a, wk2, wk2_a)
      END IF
      CALL LOC_POPREAL4ARRAY(wk2, fac_pp*mxang2) !pp_5
      CALL LOC_POPREAL4ARRAY(trnsm, fac_pp*nang2) !pp_4
      CALL MXM_A(r, r_a, nang, wk1, wk1_a, nang, wk2, wk2_a, nang)
      CALL MXM_A(wkt, wkt_a, nang, wk1, wk1_a, nang, trnsm, trnsm_a, &
&           nang)
      CALL LOC_POPREAL4ARRAY(wkt, fac_pp*mxang2) !pp_3
      CALL LOC_POPREAL4ARRAY(rm, fac_pp*mxang2)   !pp_2a
      trnsm_a(1:nang2) = trnsm_a(1:nang2) + wkt_a(1:nang2)
      wkt_a(1:nang2) = 0.0
      CALL MXM_A(rm, rm_a, nang, trnsm, trnsm_a, nang, wk1, wk1_a, nang)
      CALL LOC_POPREAL4ARRAY(rm, fac_pp*mxang2)   !pp_2
      CALL SMINV_A(rm, rm_a, nang, ierr)
      DO i=nang2,1,-1
        rm_a(i) = -rm_a(i)
      END DO
      wk3(1:nang2)=r(1:nang2)
      CALL MXM_A(r, r_a, nang, wk3, wk3_a, nang, rm, rm_a, nang)
      r_a(1:nang2)=r_a(1:nang2)+wk3_a(1:nang2)
      wk3_a(1:nang2)=0. !no longer needed
      CALL LOC_POPREAL4ARRAY(rm, fac_pp*mxang2) !pp_1
    END DO
  END SUBROUTINE DOUBL_A
!  Differentiation of emis in reverse (adjoint) mode:
!   gradient, with respect to input variables: tm em tmr
!   of linear combination of output variables: tm em tmr
!
  SUBROUTINE EMIS_A(em, em_a, tm, tm_a, tmr, tmr_a)
    IMPLICIT NONE
    INTEGER :: nang
!<f90Subroutine>********************************************************
!
! NAME:
!
!   EMIS
!
! PURPOSE:
!
!   Perform doubling of the thermal source
!
! SYNTAX:
!
!   CALL EMIS(EM, TM, TMR, WKEM)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   TM    REAL(FP)  TBD
!   TMR   REAL(FP)  TBD
!
!   INPUTS/OUTPUTS:
!
!   EM    REAL(FP)  Emission vector at NBOT0/NBOT
!   WKEM  REAL(FP)  TBD
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     This subroutine does the doubling of the thermal source
!     (see note in subroutine GENTAB)
!
!     REVISED:  04 OCTOBER 1993
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    REAL(fp), DIMENSION(nang, 2) :: em
    REAL(fp), DIMENSION(nang, 2) :: em_a
    REAL(fp), DIMENSION(nang, nang) :: tm, tmr
    REAL(fp), DIMENSION(nang, nang) :: tm_a, tmr_a
    INTEGER :: nang2
    INTEGER :: n2ang
    REAL(fp), DIMENSION(nang, 2) :: wkem
    REAL(fp), DIMENSION(nang, 2) :: wkem_a
!
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    INTEGER :: i
    INTEGER :: j
    REAL(fp) :: half=0.5
    REAL(fp) :: temp_a1
    REAL(fp) :: temp_a0
    REAL(fp) :: temp_a
!
    wkem(:,:) = em(:,:)
    em_a(1:nang, 2) = half*em_a(1:nang, 2)
    wkem_a(:, :) = 0.0
    DO i=nang,1,-1
      DO j=nang,1,-1
        temp_a = (wkem(j, 2)-wkem(j, 1))*em_a(i, 2)
        temp_a0 = (tm(j, i)-tmr(j, i))*em_a(i, 2)
        temp_a1 = wkem(j, 1)*em_a(i, 1)
        tm_a(j, i) = tm_a(j, i) + temp_a1 + temp_a
        tmr_a(j, i) = tmr_a(j, i) + temp_a1 - temp_a
        wkem_a(j, 2) = wkem_a(j, 2) + temp_a0
        wkem_a(j, 1) = wkem_a(j, 1) + (tm(j, i)+tmr(j, i))*em_a(i, 1) - &
&          temp_a0
      END DO
      em_a(i, 1) = em_a(i, 1) + em_a(i, 2)
    END DO
    em_a(:, :) = em_a(:, :) + wkem_a(:, :)
  END SUBROUTINE EMIS_A
!  Differentiation of sunb in reverse (adjoint) mode:
!   gradient, with respect to input variables: tm att sbm tmr
!   of linear combination of output variables: tm att sbm tmr
!
  SUBROUTINE SUNB_A(sbm, sbm_a, tm, tm_a, tmr, tmr_a, att, att_a)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   SUNB
!
! PURPOSE:
!
!   Perform doubling of the solar source
!
! SYNTAX:
!
!   CALL SUNB(SBM, TM, TMR, WKEM, ATT)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   TM    REAL(FP)  TBD
!   TMR   REAL(FP)  TBD
!
!   INPUTS/OUTPUTS:
!
!   SBM   REAL(FP)  upward and downward emission due to solar scattering
!   WKEM  REAL(FP)  TBD
!   ATT   REAL(FP)  TBD
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     This subroutine does the doubling of the solar source
!     (see note in subroutine GENTAB)
!
!     REVISED:  04 OCTOBER 1993
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    REAL(fp) :: att
    REAL(fp) :: att_a
    INTEGER :: nang
    REAL(fp), DIMENSION(nang, 2) :: sbm
    REAL(fp), DIMENSION(nang, 2) :: sbm_a
    REAL(fp), DIMENSION(nang, nang) :: tm, tmr
    REAL(fp), DIMENSION(nang, nang) :: tm_a, tmr_a
    INTEGER :: nang2
    INTEGER :: n2ang
    REAL(fp), DIMENSION(nang, 2) :: wkem
    REAL(fp), DIMENSION(nang, 2) :: wkem_a
!
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    INTEGER :: i
    INTEGER :: j
!
    wkem(:, :) = sbm(:, :)
    CALL LOC_PUSHREAL4ARRAY(wkem(:, 1), fac_pp*nang)
    wkem(1:nang, 1) = wkem(1:nang, 1)*att
    att_a = 2*att*att_a
    wkem_a(:, :) = 0.0
    DO i=nang,1,-1
      DO j=nang,1,-1
        tm_a(j, i) = tm_a(j, i) + wkem(j, 1)*sbm_a(i, 1) + wkem(j, 2)*&
&          sbm_a(i, 2)
        wkem_a(j, 2) = wkem_a(j, 2) + tm(j, i)*sbm_a(i, 2)
        tmr_a(j, i) = tmr_a(j, i) + wkem(j, 2)*sbm_a(i, 1) + wkem(j, 1)*&
&          sbm_a(i, 2)
        wkem_a(j, 1) = wkem_a(j, 1) + tm(j, i)*sbm_a(i, 1) + tmr(j, i)*&
&          sbm_a(i, 2)
        wkem_a(j, 2) = wkem_a(j, 2) + tmr(j, i)*sbm_a(i, 1)
      END DO
    END DO
    CALL LOC_POPREAL4ARRAY(wkem(:, 1), fac_pp*nang)
    att_a = att_a + SUM(sbm(1:nang, 2)*sbm_a(1:nang, 2)) + SUM(wkem(1:&
&      nang, 1)*wkem_a(1:nang, 1))
    wkem_a(1:nang, 1) = att*wkem_a(1:nang, 1)
    sbm_a(1:nang, 2) = att*sbm_a(1:nang, 2)
    sbm_a(:, :) = sbm_a(:, :) + wkem_a(:, :)
  END SUBROUTINE SUNB_A
!  Differentiation of addclr in reverse (adjoint) mode:
!   gradient, with respect to input variables: r empl emml em tlay
!   of linear combination of output variables: r empl emml em tlay
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     OSS (Optimal Spectral Sampling)
!     $Name:  $
!     $Id: oss_addbl.f90,v 1.6 2009/04/03 20:21:19 crichard Exp $
!     Copyright AER, Inc., 2002, 2003. All rights Reserved.
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE ADDCLR_A(r, r_a, trnsm, em, em_a, reflg, plnck, tlay, &
&    tlay_a, empl, empl_a, emml, emml_a)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   ADDCLR
!
! PURPOSE:
!
!   Perform adding of a clear layer.
!
! SYNTAX:
!
!   CALL ADDCLR(R, TRNSM, EM, REFLG, PLNCK)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   REFLG  LOGICAL  Flag for calculating surface reflectance
!   PLNCK  LOGICAL  Flag for applying Planck function
!
!   INPUTS/OUTPUTS:
!
!   R      REAL(FP)     Reflection matrix at NBOT0/NBOT
!   TRNSM  REAL(FP)     Transmission matrix at NBOT0/NBOT
!   EM     REAL(FP)     Emission vector at NBOT0/NBOT
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     This subroutine does the adding of a clear layer - Transmission
!     and internal emission for the layer must be contained in common
!     block /LAYDAT/. Results are accumulated in arrays R, TRNSM and EM.
!     Transmittance is updated only if TXON = .TRUE., and reflection
!     matrix only if non-zero initially (REFLG=.FALSE.).
!
!     REVISED:  08 MARCH 1993
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
    REAL(fp), DIMENSION(:) :: r, trnsm, em
    REAL(fp), DIMENSION(:) :: r_a, em_a
    LOGICAL, INTENT(IN) :: reflg, plnck
    REAL(fp) :: tlay(:), empl(:), emml(:)
    REAL(fp) :: tlay_a(:), empl_a(:), emml_a(:)
    REAL(fp) :: cl2inv
    REAL(fp) :: pi
!
    COMMON /constn/ pi, cl2inv
    save /constn/
    INTEGER :: nang
    INTEGER :: nang2
    INTEGER :: n2ang
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    REAL(fp) :: tr
    REAL(fp) :: tr_a
    REAL(fp) :: wkem
    REAL(fp) :: wkem_a
    DIMENSION wkem(mxang), tr(mxang2)
    DIMENSION wkem_a(mxang), tr_a(mxang2)
    INTEGER :: branch
!
    ! initialize local adjoint variables
    tr_a=0.
    wkem_a=0.
!     Update emission
!
!
    IF (plnck) THEN
      CALL PUSHINTEGER4(0)
    ELSE
      CALL PUSHINTEGER4(1)
    END IF
!
    IF (reflg) THEN
!
      CALL DMXMV(tlay, r, tr, nang)
!
      IF (plnck) THEN
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL MXDMV_A(tr, tr_a, tlay, tlay_a, r, r_a, nang)
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        wkem_a(1:mxang) = 0.0
      ELSE
        wkem_a(1:mxang) = 0.0
        wkem_a(1:nang) = em_a(1:nang)
        CALL MXVV_A(tr, tr_a, emml, emml_a, wkem, wkem_a, nang)
      END IF
      CALL DMXMV_A(tlay, tlay_a, r, r_a, tr, tr_a, nang)
    ELSE
      wkem_a(1:mxang) = 0.0
    END IF
    CALL POPINTEGER4(branch)
    IF (branch .LT. 1) THEN
      wkem_a(1:nang) = wkem_a(1:nang) + em_a(1:nang)
      empl_a(1:nang) = empl_a(1:nang) + em_a(1:nang)
      em_a(1:nang) = 0.0
    ELSE
      wkem_a(1:nang) = wkem_a(1:nang) + em_a(1:nang)
      em_a(1:nang) = 0.0
    END IF
    tlay_a(1:nang) = tlay_a(1:nang) + em(1:nang)*wkem_a(1:nang)
    em_a(1:nang) = em_a(1:nang) + tlay(1:nang)*wkem_a(1:nang)
  END SUBROUTINE ADDCLR_A
!  Differentiation of addms in reverse (adjoint) mode:
!   gradient, with respect to input variables: r empl emml em tlay
!                rlay
!   of linear combination of output variables: r empl emml em tlay
!
  SUBROUTINE ADDMS_A(r, r_a, trnsm, em, em_a, reflg, rlay, rlay_a, tlay&
&    , tlay_a, empl, empl_a, emml, emml_a)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   ADDMS
!
! PURPOSE:
!
!   General layer adding subroutine
!
! SYNTAX:
!
!   CALL ADDMS(R, TRNSM, EM, REFLG)
!
! ARGUMENTS:
!
!   INPUTS/OUTPUTS:
!
!   R      REAL(FP)     Reflection matrix at NBOT0/NBOT
!   TRNSM  REAL(FP)     Transmission matrix at NBOT0/NBOT
!   EM     REAL(FP)     Emission vector at NBOT0/NBOT
!   REFLG  LOGICAL  Flag for calculating surface reflectance
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     General layer adding routine - Reflection, transmission and
!     internal emission for the layer must be contained in common
!     block /LAYDAT/. Results are accumulated in arrays R, TRNSM and EM.
!     Transmittance is updated only if TXON = .TRUE., and reflection
!     matrix only if non-zero initially (REFLG=.FALSE.).
!
!     REVISED:  08 MARCH 1993
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
    REAL(fp), DIMENSION(:) :: r, trnsm, em
    REAL(fp), DIMENSION(:) :: r_a, em_a
    REAL(fp), DIMENSION(:) :: rlay
    REAL(fp), DIMENSION(:) :: rlay_a
    REAL(fp), DIMENSION(:) :: tlay, empl, emml
    REAL(fp), DIMENSION(:) :: tlay_a, empl_a, emml_a
    LOGICAL, INTENT(INOUT) :: reflg
    INTEGER :: nang
    INTEGER :: nang2
    INTEGER :: n2ang
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    REAL(fp) :: wkem1
    REAL(fp) :: wkem1_a
    REAL(fp) :: wk1
    REAL(fp) :: wk1_a
    REAL(fp) :: wkem2
    REAL(fp) :: wkem2_a
    REAL(fp) :: wk2
    REAL(fp) :: wk2_a
    REAL(fp) :: rm
    REAL(fp) :: rm_a
    DIMENSION rm(mxang2), wk1(mxang2), wk2(mxang2), wkem1(mxang), wkem2(&
&        mxang)
    DIMENSION rm_a(mxang2), wk1_a(mxang2), wk2_a(mxang2), wkem1_a(mxang)&
&        , wkem2_a(mxang)
!
!      EQUIVALENCE (WK0,RM)
    ! initialize local adjoint variables
    wkem1_a=0.
    wk1_a=0.
    wkem2_a=0.
    wk2_a=0.
    rm_a=0.
!
    IF (reflg) THEN
!
!     Calculate multiple reflection term (result in RM)
!
      CALL MLREF(r, rlay, rm)
!
!     Update emission
!
      CALL MXMV(tlay, rm, wk1, nang)
      CALL MXMV(wk1, r, wk2, nang)
!
!     Update reflection matrix
!
!       -- old call:
!         CALL MXMV(WK2,TLAY,WK0,NANG)
!         CALL SVADD(WK0,RLAY,R,NANG2)
!       -- new call, removing equivalence:
!
!!$      rlay_a(:) = 0.0 !?? new
      rm_a(1:mxang2) = 0.0
      rm_a(1:nang2) = r_a(1:nang2)
!!$      rlay_a(1:nang2) = r_a(1:nang2) !?? not: rlay_a(1:nang2) = rlay_a(1:nang2) + r_a(1:nang2)
      rlay_a(1:nang2) = rlay_a(1:nang2) + r_a(1:nang2)
      r_a(1:nang2) = 0.0
      wk2_a(:) = 0.0
      CALL MXMV_A(wk2, wk2_a, tlay, tlay_a, rm, rm_a, nang)
      empl_a(1:nang) = empl_a(1:nang) + em_a(1:nang)
      wkem1_a(1:mxang) = 0.0
      wkem2_a(1:mxang) = 0.0
      wkem1_a(1:nang) = em_a(1:nang)
      wkem2_a(1:nang) = em_a(1:nang)
      em_a(1:nang) = 0.0
      CALL MXVV_A(wk2, wk2_a, emml, emml_a, wkem2, wkem2_a, nang)
      wk1_a(:) = 0.0
      CALL MXVV_A(wk1, wk1_a, em, em_a, wkem1, wkem1_a, nang)
      CALL MXMV_A(wk1, wk1_a, r, r_a, wk2, wk2_a, nang)
      CALL MXMV_A(tlay, tlay_a, rm, rm_a, wk1, wk1_a, nang)
      CALL MLREF_A(r, r_a, rlay, rlay_a, rm, rm_a)
    ELSE
!!$      rlay_a(:) = 0.0 !?? new
!!$      rlay_a(1:nang2) = r_a(1:nang2) !?? not: rlay_a(1:nang2) = rlay_a(1:nang2) + r_a(1:nang2)
      rlay_a(1:nang2) = rlay_a(1:nang2) + r_a(1:nang2)
      r_a(1:nang2) = 0.0
      wkem1_a(1:mxang) = 0.0
      empl_a(1:nang) = empl_a(1:nang) + em_a(1:nang)
      wkem1_a(1:nang) = em_a(1:nang)
      em_a(1:nang) = 0.0
      CALL MXVV_A(tlay, tlay_a, em, em_a, wkem1, wkem1_a, nang)
    END IF
  END SUBROUTINE ADDMS_A
!  Differentiation of mrgrad in reverse (adjoint) mode:
!   gradient, with respect to input variables: rb rf emb emf rad
!   of linear combination of output variables: rad
!
  SUBROUTINE MRGRAD_A(rf, rf_a, emf, emf_a, rb, rb_a, emb, emb_a, reflf&
&    , reflb, rad, rad_a)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   MRGRAD
!
! PURPOSE:
!
!   Calculate the observed radiances by combining reflection and emission of the
!   atmosphere below and above the observer level.
!
! SYNTAX:
!
!   CALL MRGRAD(RF, EMF, RB, EMB, REFLF, REFLB, RAD)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   REFLF  LOGICAL  Flag to show whether in front of observer atmosphere
!                   reflecting
!   REFLB  LOGICAL  Flag to show whether behind observer atmosphere
!                   reflecting
!
!   INPUTS/OUTPUTS:
!
!   RF     REAL(FP)     Atmosphere Reflection in front of observer
!   EMF    REAL(FP)     Atmosphere Emission in front of observer
!   RB     REAL(FP)     Atmosphere Reflection behind observer
!   EMB    REAL(FP)     Atmosphere Emission behind observer
!   RAD    REAL(FP)     Radiance
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     This subroutine calculates the observed radiances by combining
!     reflection and emission of the atmosphere below and above the
!     observer level.
!
!     Flags REFLF/REFLB indicate whether the portion of the atmosphere
!     in front of/behind the observer is reflecting
!
!     REVISED:  11 OCTOBER 1993
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
    REAL(fp), DIMENSION(:) :: rf, emf, rb, emb, rad
    REAL(fp), DIMENSION(:) :: rf_a, emf_a, rb_a, emb_a, rad_a
    LOGICAL, INTENT(IN) :: reflf, reflb
    INTEGER :: nang
    INTEGER :: nang2
    INTEGER :: n2ang
!
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    REAL(fp) :: radtmp
    REAL(fp) :: radtmp_a
    REAL(fp) :: rm
    REAL(fp) :: rm_a
    DIMENSION rm(mxang2), radtmp(mxang)
    DIMENSION rm_a(mxang2), radtmp_a(mxang)
    ! initialize local adjoint variables
    radtmp_a=0.
    rm_a=0.
!
    IF (.NOT.reflf) THEN
      emf_a(:) = 0.0
      emf_a(1:nang) = rad_a(1:nang)
      rad_a(1:nang) = 0.0
!!$      rb_a(:) = 0.0
!!$      rf_a(:) = 0.0
!!$      emb_a(:) = 0.0
    ELSE IF (.NOT.reflb) THEN
!!$      emf_a(:) = 0.0
      emf_a(1:nang) = emf_a(1:nang) + rad_a(1:nang)
!!$      rf_a(:) = 0.0
!!$      emb_a(:) = 0.0
      CALL MXVV_A(rf, rf_a, emb, emb_a, rad, rad_a, nang)
!!$      rb_a(:) = 0.0
    ELSE
      CALL MLREF(rf, rb, rm)
      CALL MXVV(rf, emb, radtmp, nang)
      radtmp(1:nang) = emf(1:nang) + radtmp(1:nang)
!!$      rm_a(:) = 0.0
!!$      radtmp_a(:) = 0.0
      CALL MXVV_A(rm, rm_a, radtmp, radtmp_a, rad, rad_a, nang)
!!$      emf_a(:) = 0.0
      emf_a(1:nang) = emf_a(1:nang) + radtmp_a(1:nang)
!!$      rf_a(:) = 0.0
!!$      emb_a(:) = 0.0
      CALL MXVV_A(rf, rf_a, emb, emb_a, radtmp, radtmp_a, nang)
!!$      rb_a(:) = 0.0
      CALL MLREF_A(rf, rf_a, rb, rb_a, rm, rm_a)
    END IF
  END SUBROUTINE MRGRAD_A
!  Differentiation of mlref in reverse (adjoint) mode:
!   gradient, with respect to input variables: ra rb
!   of linear combination of output variables: ra rb rm
!
  SUBROUTINE MLREF_A(ra, ra_a, rb, rb_a, rm, rm_a)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   MLREF
!
! PURPOSE:
!
!   Calculates multiple reflection term by truncated series.
!
! SYNTAX:
!
!   CALL MLREF(RA, RB)
!
! ARGUMENTS:
!
!   INPUTS/OUTPUTS:
!
!   RA  REAL(FP)  Atmosphere Reflection in front of observer
!   RB  REAL(FP)  Atmosphere Reflection behind observer
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     Calculates multiple reflection term by truncated series.
!
!     REVISED:  11 OCTOBER 1993
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
    REAL(fp), DIMENSION(:) :: ra, rb
    REAL(fp), DIMENSION(:) :: ra_a, rb_a
    REAL(fp), DIMENSION(:) :: rm
    REAL(fp), DIMENSION(:) :: rm_a
    INTEGER :: nang
    INTEGER :: nang2
    INTEGER :: n2ang
!
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    REAL(fp) :: q1
    REAL(fp) :: q1_a
    REAL(fp) :: q2
    REAL(fp) :: q2_a
    REAL(fp) :: q3(mxang2)
    REAL(fp) :: q3_a(mxang2)
    REAL(fp) :: rab
    REAL(fp) :: rab_a
    DIMENSION rab(mxang2), q1(mxang2), q2(mxang2)
    DIMENSION rab_a(mxang2), q1_a(mxang2), q2_a(mxang2)
    INTEGER :: i
    ! initialize local adjoint variables
    q1_a=0.
    q2_a=0.
    q3_a=0.
    rab_a=0.
!
    CALL MXMV(ra, rb, rab, nang)
!
    q3(1:nang2)=rab(1:nang2)
    CALL MXMV(rab, q3, q1, nang)
!
    CALL MXMV(rab, q1, q2, nang)
    CALL LOC_PUSHREAL4ARRAY(q1, fac_pp*mxang2)
!
    CALL MXMV(rab, q2, q1, nang)
    CALL LOC_PUSHREAL4ARRAY(q2, fac_pp*mxang2)
!
    CALL MXMV(rab, q1, q2, nang)
    CALL HOCOR_A(rm, rm_a, q1, q1_a, q2, q2_a)
    CALL LOC_POPREAL4ARRAY(q2, fac_pp*mxang2)
    rab_a(:) = 0.0
    CALL MXMV_A(rab, rab_a, q1, q1_a, q2, q2_a, nang)
    q1_a(1:nang2) = q1_a(1:nang2) + rm_a(1:nang2)
    CALL LOC_POPREAL4ARRAY(q1, fac_pp*mxang2)
    CALL MXMV_A(rab, rab_a, q2, q2_a, q1, q1_a, nang)
    q2_a(1:nang2) = q2_a(1:nang2) + rm_a(1:nang2)
    CALL MXMV_A(rab, rab_a, q1, q1_a, q2, q2_a, nang)
    rab_a(1:nang2) = rab_a(1:nang2) + rm_a(1:nang2)
    q1_a(1:nang2) = q1_a(1:nang2) + rm_a(1:nang2)
    q3(1:nang2)=rab(1:nang2)
    CALL MXMV_A(rab, rab_a, q3, q3_a, q1, q1_a, nang)
    rab_a(:)=rab_a(:)+q3_a(:)
    q3_a(:)=0. !no longer needed
    CALL MXMV_A(ra, ra_a, rb, rb_a, rab, rab_a, nang)
  END SUBROUTINE MLREF_A
!  Differentiation of hocor in reverse (adjoint) mode:
!   gradient, with respect to input variables: rm q1 q2
!   of linear combination of output variables: rm
!
  SUBROUTINE HOCOR_A(rm, rm_a, q1, q1_a, q2, q2_a)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   HOCOR
!
! PURPOSE:
!
!   Correction for missing high order terms in MLREF
!
! SYNTAX:
!
!   CALL HOCOR(RM, Q1, Q2)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   Q1  REAL(FP)  TBD
!   Q2  REAL(FP)  TBD
!
!   INPUTS/OUTPUTS:
!
!   RM  REAL(FP)  TBD
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     Correction for missing high order terms in MLREF
!
!     REVISED:  13 APRIL 1994
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    REAL(fp), DIMENSION(:) :: rm
    REAL(fp), DIMENSION(:) :: rm_a
    REAL(fp), DIMENSION(:) :: q1, q2
    REAL(fp), DIMENSION(:) :: q1_a, q2_a
    INTEGER :: nang
    INTEGER :: nang2
    INTEGER :: n2ang
!
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    INTEGER :: l
    REAL(fp) :: epsil
    INTRINSIC MOD
    REAL(fp) :: temp
    INTEGER :: branch
    REAL(fp) :: temp0_a
    REAL(fp) :: temp_a
    DATA epsil /1.e-16/
    ! initialize local adjoint variables
    temp0_a=0.
    temp_a=0.
!
    DO l=1,nang2
      IF (MOD(l, nang) .NE. 0) THEN
        CALL PUSHINTEGER4(2)
      ELSE
        CALL PUSHINTEGER4(1)
      END IF
    END DO
!!$    q1_a(:) = 0.0
!!$    q2_a(:) = 0.0
    DO l=nang2,1,-1
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 2) THEN
        temp = epsil + q1(l) - q2(l)
        temp0_a = rm_a(l)/temp
        temp_a = -(q2(l)*q1(l)*temp0_a/temp)
        q2_a(l) = q2_a(l) + q1(l)*temp0_a - temp_a
        q1_a(l) = q1_a(l) + temp_a + q2(l)*temp0_a
      END IF
    END DO
  END SUBROUTINE HOCOR_A
!  Differentiation of mxm in reverse (adjoint) mode:
!   gradient, with respect to input variables: a b c
!   of linear combination of output variables: a b c
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     OSS (Optimal Spectral Sampling)
!     $Name:  $
!     $Id: oss_addbl.f90,v 1.6 2009/04/03 20:21:19 crichard Exp $
!     Copyright AER, Inc., 2002, 2003. All rights Reserved.
!     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!     VECTOR OPERATIONS
!     REVISED:  04 OCTOBER 1993
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  SUBROUTINE MXM_A(a, a_a, nar, b, b_a, nac, c, c_a, nbc)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   MXM
!
! PURPOSE:
!
!   Product of two matrices
!
! SYNTAX:
!
!   CALL MXM(A, NAR, B, NAC, C, NBC)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   A    REAL(FP)     Generic array
!   NAR  INTEGER  Number of rows of matrix A
!   B    REAL(FP)     Generic array
!   NAC  INTEGER  Number of columns of matrix A
!   NBC  INTEGER  Number of columns of matrices B and C
!
!   INPUTS/OUTPUTS:
!
!   C    REAL(FP)     Generic array
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
! **********************************************************************
! *   CALCULATES PRODUCT OF TWO MATRICES--C=BA AND ASSUMES THE         *
! *   SKIP DISTANCE BETWEEN ELEMENTS TO BE 1.                          *
! *                                                                    *
! *   REVISED:  11-11-93 (D. PORTMAN)                                  *
! *                                                                    *
! *   ARGUMENTS:                                                       *
! *                                                                    *
! *   A       (input) Second matrix of product.                        *
! *   NAR     (input/output) Number of rows of matrices A and C.       *
! *   B       (input) First matrix of product.                         *
! *   NAC     (input) Number of columns of matrix A and the number of  *
! *           rows of matrix B.                                        *
! *   C       (output) Result matrix.                                  *
! *   NBC     (input/output) Number of columns of matrices B and C.    *
! *                                                                    *
! **********************************************************************
    INTEGER, INTENT(IN) :: nar, nac, nbc
    REAL(fp), DIMENSION(nar, nac) :: a
    REAL(fp), DIMENSION(nar, nac) :: a_a
    REAL(fp), DIMENSION(nac, nbc) :: b
    REAL(fp), DIMENSION(nac, nbc) :: b_a
    REAL(fp), DIMENSION(nar, nbc) :: c
    REAL(fp), DIMENSION(nar, nbc) :: c_a
    INTEGER :: i
    INTEGER :: j
    REAL(fp) :: sum
    REAL(fp) :: sum_a
    INTEGER :: k
    sum_a=0.
! initialize local adjoint variables
    DO i=nar,1,-1
      DO j=nbc,1,-1
        sum_a = c_a(i, j)
        c_a(i, j) = 0.0
        DO k=nac,1,-1
          a_a(i, k) = a_a(i, k) + b(k, j)*sum_a
          b_a(k, j) = b_a(k, j) + a(i, k)*sum_a
        END DO
      END DO
    END DO
  END SUBROUTINE MXM_A
!  Differentiation of sminv in reverse (adjoint) mode:
!   gradient, with respect to input variables: a
!   of linear combination of output variables: a
!
  SUBROUTINE SMINV_A(a, a_a, n, ierr)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   sMINV
!
! PURPOSE:
!
!   Invert a double precision matrix
!
! SYNTAX:
!
!   CALL sMINV(A, N, D, L, M)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   N  INTEGER  Dimension of array
!
!   INPUTS/OUTPUTS:
!
!   A  REAL(FP)     Generic array
!   D  REAL(FP)     Matrix determinant
!   L  REAL(FP)     Workspace vector
!   M  REAL(FP)     Workspace vector
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
! **********************************************************************
! ROUTINE          DMINV   SUBROUTINE  *****  [EYRE.RETCOF]
!
! PURPOSE          TO INVERT A DOUBLE PRECISION MATRIX
!
! VERSION          3.00,150385,J.R.EYRE
!
! DESCRIPTION      ROUTINE TO INVERT A DOUBLE PRECISION MATRIX.
!                  METHOD: THE STANDARD GAUSS-JORDAN METHOD IS USED.
!                  THE DETERMINANT IS ALSO CALCULATED. A DETERMINANT
!                  OF ZERO INDICATES THAT THE MATRIX IS SINGULAR.
!
! ARGUMENTS        A      R*8 INPUT MATRIX, DESTROYED IN COMPUTATION AND
!                             REPLACED BY RESULTANT INVERSE.
!                  N      I*4 ORDER OF MATRIX A
!                  D      R*8 RESULTANT DETERMINANT
!                  L      R*8 WORK VECTOR OF LENGTH N
!                  M      R*8 WORK VECTOR OF LENGTH N
!
!     ..................................................................
!
    INTEGER, INTENT(IN) :: n
    REAL(fp), DIMENSION(n*n) :: a
    REAL(fp), DIMENSION(n*n) :: a_a
    INTEGER, INTENT(OUT) :: ierr
    REAL(fp) :: d
    REAL(fp), DIMENSION(n) :: l, m
!
    REAL(fp) :: biga, hold
    REAL(fp) :: biga_a, hold_a
    INTEGER :: nk
    INTEGER :: k
    INTEGER :: kk
    INTEGER :: j
    INTEGER :: i
    INTEGER :: ij
    INTEGER :: ki
    INTEGER :: ji
    INTEGER :: jk
    INTEGER :: ik
    INTEGER :: kj
    INTEGER :: jq
    INTEGER :: jr
    INTRINSIC ABS
    REAL(fp) :: abs2
    REAL(fp) :: abs1
!
!     ..................................................................
!
!        IF A DOUBLE PRECISION VERSION OF THIS ROUTINE IS DESIRED, THE
!        C$ IN COLUMNS 1-2 SHOULD BE REMOVED FROM THE DOUBLE PRECISION
!        STATEMENT WHICH FOLLOWS.
!
!$      REAL(Double) A,D,BIGA,HOLD
!        REAL(FP) A,D,BIGA,HOLD,L,M
!
!        THE C MUST ALSO BE REMOVED FROM DOUBLE PRECISION STATEMENTS
!        APPEARING IN OTHER ROUTINES USED IN CONJUNCTION WITH THIS
!        ROUTINE.
!
!        THE DOUBLE PRECISION VERSION OF THIS SUBROUTINE MUST ALSO
!        CONTAIN DOUBLE PRECISION FORTRAN FUNCTIONS.  ABS IN STATEMENT
!        10 MUST BE CHANGED TO DABS.
!
! **********************************************************************
!
!        SEARCH FOR LARGEST ELEMENT
!
    REAL(fp) :: tmp
    REAL(fp) :: tmp_a
    REAL(fp) :: tmp0
    REAL(fp) :: tmp0_a
    REAL(fp) :: tmp1
    REAL(fp) :: tmp1_a
    REAL(fp) :: tmp2
    REAL(fp) :: tmp2_a
    REAL(fp) :: tmp3
    REAL(fp) :: tmp3_a
    INTEGER :: ad_from
    INTEGER :: ad_from0
    INTEGER :: branch

    ! initialize local adjoint variables
    biga_a=0.
    hold_a=0.
    tmp_a=0.
    tmp0_a=0.
    tmp1_a=0.
    tmp2_a=0.
    tmp3_a=0.
    DO k=1,n
      nk = (k-1)*n
      l(k) = k
      m(k) = k
      CALL PUSHINTEGER4(kk)
      kk = nk + k
      CALL PUSHREALFP(biga)
      biga = a(kk)
      ad_from = k
      DO j=ad_from,n
        ad_from0 = k
        DO i=ad_from0,n
          CALL PUSHINTEGER4(ij)
          ij = (j-1)*n + i
          IF (biga .GE. 0.) THEN
            abs1 = biga
          ELSE
            abs1 = -biga
          END IF
          IF (a(ij) .GE. 0.) THEN
            abs2 = a(ij)
          ELSE
            abs2 = -a(ij)
          END IF
!$ 10           IF(DABS(BIGA)-DABS(A(IJ))) 15,20,20
          IF (abs1 - abs2 .LT. 0) THEN
            biga = a(ij)
            l(k) = i
            m(k) = j
            CALL PUSHINTEGER4(2)
          ELSE
            CALL PUSHINTEGER4(1)
          END IF
        END DO
        CALL PUSHINTEGER4(ad_from0)
      END DO
      CALL PUSHINTEGER4(ad_from)
      j = l(k)
!
!        INTERCHANGE ROWS
!
      IF (j - k .NE. 0) THEN
        DO i=1,n
          CALL PUSHINTEGER4(ki)
          ki = k + (i-1)*n
          CALL PUSHREALFP(hold)
          hold = -a(ki)
          CALL PUSHINTEGER4(ji)
          ji = ki - k + j
          tmp = a(ji)
          CALL PUSHREALFP(a(ki))
          a(ki) = tmp
          CALL PUSHREALFP(a(ji))
          a(ji) = hold
        END DO
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
!!$        END IF
      i = m(k)
!
!        INTERCHANGE COLUMNS
!
      IF (i - k .NE. 0) THEN
        DO j=1,n
          CALL PUSHINTEGER4(jk)
          jk = nk + j
          CALL PUSHINTEGER4(ji)
          ji = n*(i-1) + j
          CALL PUSHREALFP(hold)
          hold = -a(jk)
          tmp0 = a(ji)
          CALL PUSHREALFP(a(jk))
          a(jk) = tmp0
          CALL PUSHREALFP(a(ji))
          a(ji) = hold
        END DO
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
!
!        DIVIDE COLUMN BY MINUS PIVOT (VALUE OF PIVOT ELEMENT IS
!        CONTAINED IN BIGA)
!
      IF (biga .EQ. 0) THEN
         d = 0.0
         ierr = 1
         RETURN
      END IF
      DO i=1,n
        IF (i - k .NE. 0) THEN
          CALL PUSHINTEGER4(ik)
!!$        IF (.NOT.i - k .LT. 0) THEN
!!$          IF (i - k .EQ. 0) GOTO 55
!!$        END IF
          ik = nk + i
          CALL PUSHREALFP(a(ik))
          a(ik) = a(ik)/(-biga)
          CALL PUSHINTEGER4(3)
        ELSE
          CALL PUSHINTEGER4(2)
        END IF
      END DO
!!$ 55     CONTINUE
!
!        REDUCE MATRIX
!
      DO i=1,n
        CALL PUSHINTEGER4(ik)
        ik = nk + i
        CALL PUSHREALFP(hold)
        hold = a(ik)
        DO j=1,n
          IF (i - k .NE. 0 .AND. j - k .NE. 0) THEN
            CALL PUSHINTEGER4(ij)
!!$          IF (.NOT.i - k .LT. 0) THEN
!!$            IF (i - k .EQ. 0) GOTO 65
!!$          END IF
!!$          IF (.NOT.j - k .LT. 0) THEN
!!$            IF (j - k .EQ. 0) GOTO 65
!!$          END IF
            ij = (j-1)*n + i
            CALL PUSHINTEGER4(kj)
            kj = ij - i + k
            tmp1 = hold*a(kj) + a(ij)
            CALL PUSHREALFP(a(ij))
            a(ij) = tmp1
            CALL PUSHINTEGER4(2)
          ELSE
            CALL PUSHINTEGER4(1)
          END IF
        END DO
      END DO
      CALL PUSHINTEGER4(kj)
!!$ 65       CONTINUE
!
!        DIVIDE ROW BY PIVOT
!
      kj = k - n
      DO j=1,n
        CALL PUSHINTEGER4(kj)
        kj = kj + n
        IF (j - k .NE. 0) THEN
          CALL PUSHREALFP(a(kj))
!!$        IF (.NOT.j - k .LT. 0) THEN
!!$          IF (j - k .EQ. 0) GOTO 75
!!$        END IF
          a(kj) = a(kj)/biga
          CALL PUSHINTEGER4(2)
        ELSE
          CALL PUSHINTEGER4(1)
        END IF
      END DO
      CALL PUSHREALFP(a(kk))
!!$ 75     CONTINUE
!
!        PRODUCT OF PIVOTS
!
!
!        REPLACE PIVOT BY RECIPROCAL
!
      a(kk) = 1.0/biga
    END DO
!
!        FINAL ROW AND COLUMN INTERCHANGE
!
    DO k=n,1,-1
!!$    k = n
!!$ 100 k = k - 1
!!$    IF (.NOT.k .LT. 0) THEN
!!$      IF (.NOT.k .EQ. 0) THEN
      i = l(k)
      IF (i - k .NE. 0) THEN
!!$       IF (.NOT.i - k .LT. 0) THEN
!!$          IF (.NOT.i - k .EQ. 0) THEN
        jq = n*(k-1)
        jr = n*(i-1)
        DO j=1,n
          CALL PUSHINTEGER4(jk)
          jk = jq + j
          CALL PUSHINTEGER4(ji)
          ji = jr + j
        END DO
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
!!$          END IF
      j = m(k)
      IF (j - k .NE. 0) THEN
        CALL PUSHINTEGER4(ki)
!!$        IF (.NOT.j - k .LT. 0) THEN
!!$          IF (.NOT.j - k .EQ. 0) THEN
        ki = k - n
        DO i=1,n
          CALL PUSHINTEGER4(ki)
          ki = ki + n
          CALL PUSHINTEGER4(ji)
          ji = ki - k + j
        END DO
        CALL PUSHINTEGER4(2)
      ELSE
        CALL PUSHINTEGER4(1)
      END IF
    END DO

    DO k=1,n,1
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 2) THEN
        DO i=n,1,-1
          hold_a = a_a(ji)
          a_a(ji) = 0.0
          tmp3_a = a_a(ki)
          a_a(ki) = 0.0
          a_a(ji) = a_a(ji) - tmp3_a
          CALL POPINTEGER4(ji)
          a_a(ki) = a_a(ki) + hold_a
          CALL POPINTEGER4(ki)
        END DO
        CALL POPINTEGER4(ki)
      END IF
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        DO j=n,1,-1
          hold_a = a_a(ji)
          a_a(ji) = 0.0
          tmp2_a = a_a(jk)
          a_a(jk) = 0.0
          a_a(ji) = a_a(ji) - tmp2_a
          CALL POPINTEGER4(ji)
          a_a(jk) = a_a(jk) + hold_a
          CALL POPINTEGER4(jk)
        END DO
      END IF
    END DO

    DO k=n,1,-1
      CALL POPREALFP(a(kk))
      biga_a = -(a_a(kk)/biga**2)
      a_a(kk) = 0.0
      DO j=n,1,-1
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 2) THEN
          CALL POPREALFP(a(kj))
          biga_a = biga_a - a(kj)*a_a(kj)/biga**2
          a_a(kj) = a_a(kj)/biga
        END IF
        CALL POPINTEGER4(kj)
      END DO
      CALL POPINTEGER4(kj)
      DO i=n,1,-1
        hold_a = 0.0
        DO j=n,1,-1
          CALL POPINTEGER4(branch)
          IF (.NOT.branch .LT. 2) THEN
            CALL POPREALFP(a(ij))
            tmp1_a = a_a(ij)
            a_a(ij) = 0.0
            hold_a = hold_a + a(kj)*tmp1_a
            a_a(kj) = a_a(kj) + hold*tmp1_a
            a_a(ij) = a_a(ij) + tmp1_a
            CALL POPINTEGER4(kj)
            CALL POPINTEGER4(ij)
          END IF
        END DO
        CALL POPREALFP(hold)
        a_a(ik) = a_a(ik) + hold_a
        CALL POPINTEGER4(ik)
      END DO
      DO i=n,1,-1
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 3) THEN
          CALL POPREALFP(a(ik))
          biga_a = biga_a + a(ik)*a_a(ik)/biga**2
          a_a(ik) = -(a_a(ik)/biga)
          CALL POPINTEGER4(ik)
        END IF
      END DO
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        DO j=n,1,-1
          CALL POPREALFP(a(ji))
          hold_a = a_a(ji)
          a_a(ji) = 0.0
          CALL POPREALFP(a(jk))
          tmp0_a = a_a(jk)
          a_a(jk) = 0.0
          a_a(ji) = a_a(ji) + tmp0_a
          CALL POPREALFP(hold)
          a_a(jk) = a_a(jk) - hold_a
          CALL POPINTEGER4(ji)
          CALL POPINTEGER4(jk)
        END DO
      END IF
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        DO i=n,1,-1
          CALL POPREALFP(a(ji))
          hold_a = a_a(ji)
          a_a(ji) = 0.0
          CALL POPREALFP(a(ki))
          tmp_a = a_a(ki)
          a_a(ki) = 0.0
          a_a(ji) = a_a(ji) + tmp_a
          CALL POPINTEGER4(ji)
          CALL POPREALFP(hold)
          a_a(ki) = a_a(ki) - hold_a
          CALL POPINTEGER4(ki)
        END DO
      END IF
      CALL POPINTEGER4(ad_from)
      DO j=n,ad_from,-1
        CALL POPINTEGER4(ad_from0)
        DO i=n,ad_from0,-1
          CALL POPINTEGER4(branch)
          IF (.NOT.branch .LT. 2) THEN
            a_a(ij) = a_a(ij) + biga_a
            biga_a = 0.0
          END IF
          CALL POPINTEGER4(ij)
        END DO
      END DO
      CALL POPREALFP(biga)
      a_a(kk) = a_a(kk) + biga_a
      CALL POPINTEGER4(kk)
    END DO
  END SUBROUTINE SMINV_A
!  Differentiation of mxmv in reverse (adjoint) mode:
!   gradient, with respect to input variables: a b c
!   of linear combination of output variables: a b c
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!     VECTORIZED CHAIN MATRIX AND MATRIX/VECTOR OPERATIONS
!     REVISED:  04 OCTOBER 1993
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  SUBROUTINE MXMV_A(a, a_a, b, b_a, c, c_a, isiz)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   MXMV
!
! PURPOSE:
!
!   Product second matrix by first matrix, where both are square.
!
! SYNTAX:
!
!   CALL MXMV(A, B, C, ISIZ)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   A     REAL(FP)     Generic array
!   B     REAL(FP)     Generic array
!   ISIZ  INTEGER  Dimension of array
!
!   INPUTS/OUTPUTS:
!
!   C     REAL(FP)     Generic array
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
    INTEGER, INTENT(IN) :: isiz
    REAL(fp), DIMENSION(isiz, isiz) :: a, b
    REAL(fp), DIMENSION(isiz, isiz) :: a_a, b_a
    REAL(fp), DIMENSION(isiz, isiz) :: c
    REAL(fp), DIMENSION(isiz, isiz) :: c_a
    INTEGER :: i
    INTEGER :: j
    INTEGER :: k
    DO i=isiz,1,-1
      DO j=isiz,1,-1
        DO k=isiz,1,-1
          a_a(k, i) = a_a(k, i) + b(j, k)*c_a(j, i)
          b_a(j, k) = b_a(j, k) + a(k, i)*c_a(j, i)
        END DO
        c_a(j, i) = 0.0
      END DO
    END DO
  END SUBROUTINE MXMV_A
!  Differentiation of dmxmv in reverse (adjoint) mode:
!   gradient, with respect to input variables: a b
!   of linear combination of output variables: a b c
!
  SUBROUTINE DMXMV_A(a, a_a, b, b_a, c, c_a, isiz)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   DMXMV
!
! PURPOSE:
!
!   Product square matrix by diagonal matrix (stored as a vector). Result is
!   matrix.
!
! SYNTAX:
!
!   CALL DMXMV(A, B, C, ISIZ)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   A     REAL(FP)     Generic array
!   B     REAL(FP)     Generic array
!   ISIZ  INTEGER  Dimension of array
!
!   INPUTS/OUTPUTS:
!
!   C     REAL(FP)     Generic array
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
    INTEGER, INTENT(IN) :: isiz
    REAL(fp), DIMENSION(isiz) :: a
    REAL(fp), DIMENSION(isiz) :: a_a
    REAL(fp), DIMENSION(isiz, isiz) :: b
    REAL(fp), DIMENSION(isiz, isiz) :: b_a
    REAL(fp), DIMENSION(isiz, isiz) :: c
    REAL(fp), DIMENSION(isiz, isiz) :: c_a
    INTEGER :: i
    INTEGER :: j
    DO i=isiz,1,-1
      DO j=isiz,1,-1
        a_a(i) = a_a(i) + b(j, i)*c_a(j, i)
        b_a(j, i) = b_a(j, i) + a(i)*c_a(j, i)
        c_a(j, i) = 0.0
      END DO
    END DO
  END SUBROUTINE DMXMV_A
!  Differentiation of mxdmv in reverse (adjoint) mode:
!   gradient, with respect to input variables: a b c
!   of linear combination of output variables: b c
!
  SUBROUTINE MXDMV_A(a, a_a, b, b_a, c, c_a, isiz)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   MXDMV
!
! PURPOSE:
!
!   Product diagonal matrix (stored as a vector) by a square matrix. Result is
!   matrix.
!
! SYNTAX:
!
!   CALL MXDMV(A, B, C, ISIZ)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   A     REAL(FP)     Generic array
!   B     REAL(FP)     Generic array
!   ISIZ  INTEGER  Dimension of array
!
!   INPUTS/OUTPUTS:
!
!   C     REAL(FP)     Generic array
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
    INTEGER, INTENT(IN) :: isiz
    REAL(fp), DIMENSION(isiz) :: b
    REAL(fp), DIMENSION(isiz) :: b_a
    REAL(fp), DIMENSION(isiz, isiz) :: a
    REAL(fp), DIMENSION(isiz, isiz) :: a_a
    REAL(fp), DIMENSION(isiz, isiz) :: c
    REAL(fp), DIMENSION(isiz, isiz) :: c_a
    INTEGER :: i
    INTEGER :: j
    a_a(:, :) = 0.0
    DO i=isiz,1,-1
      DO j=isiz,1,-1
        a_a(j, i) = a_a(j, i) + b(j)*c_a(j, i)
        b_a(j) = b_a(j) + a(j, i)*c_a(j, i)
        c_a(j, i) = 0.0
      END DO
    END DO
  END SUBROUTINE MXDMV_A
!  Differentiation of mxvv in reverse (adjoint) mode:
!   gradient, with respect to input variables: a b c
!   of linear combination of output variables: a b c
!
  SUBROUTINE MXVV_A(a, a_a, b, b_a, c, c_a, isiz)
    IMPLICIT NONE
!<f90Subroutine>********************************************************
!
! NAME:
!
!   MXVV
!
! PURPOSE:
!
!   Product vector (transposed) by matrix. Result is vector.
!
! SYNTAX:
!
!   CALL MXVV(A, B, C, ISIZ)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   A     REAL(FP)     Generic array
!   B     REAL(FP)     Generic array
!   ISIZ  INTEGER  Dimension of array
!
!   INPUTS/OUTPUTS:
!
!   C     REAL(FP)     Generic array
!
!   * OPTIONAL
!
! INCLUDES:
!
!   None
!
!*******************************************************</f90Subroutine>
    INTEGER, INTENT(IN) :: isiz
    REAL(fp), DIMENSION(isiz) :: b
    REAL(fp), DIMENSION(isiz) :: b_a
    REAL(fp), DIMENSION(isiz, isiz) :: a
    REAL(fp), DIMENSION(isiz, isiz) :: a_a
    REAL(fp), DIMENSION(isiz) :: c
    REAL(fp), DIMENSION(isiz) :: c_a
    INTEGER :: i
    INTEGER :: j
    DO i=isiz,1,-1
      DO j=isiz,1,-1
        a_a(j, i) = a_a(j, i) + b(j)*c_a(i)
        b_a(j) = b_a(j) + a(j, i)*c_a(i)
      END DO
      c_a(i) = 0.0
    END DO
  END SUBROUTINE MXVV_A
!  Differentiation of wnplan in reverse (adjoint) mode:
!   gradient, with respect to input variables: tem
!   of linear combination of output variables: tem wnplan
  SUBROUTINE WNPLAN_A0(vn, tem, tem_a, wnplan_a)
    IMPLICIT NONE
!<f90Function>**********************************************************
!
! NAME:
!
!   WNPLAN
!
! PURPOSE:
!
!   Planck function, with internal calculations in double precision.
!
! SYNTAX:
!
!   Results=WNPLAN(VN, TEM)
!
! ARGUMENTS:
!
!   INPUTS:
!
!   VN      REAL(Double)  Wavenumber, units of cm^-1
!   TEM     REAL(FP)    level temperature
!
!   * OPTIONAL
!
! RETURN:
!
!     REAL(FP)
!
! INCLUDES:
!
!   None
!
!*********************************************************</f90Function>
! $ TEMPERATURE TO PLANCK RADIANCE (HMW)
! $ 'NEW' PLANCK'S CONSTANT, VELOCITY OF LIGHT, BOLTZMANN'S CONSTANT
! Units are mw*cm/m2/sr
    REAL(fp) :: tem
    REAL(fp) :: tem_a
    REAL(DOUBLE), INTENT(IN) :: vn
    REAL(fp) :: wnplan
    REAL(fp) :: wnplan_a
    REAL(Double), parameter :: c1=RADCN1
    REAL(Double), parameter :: c2=RADCN2
    REAL(DOUBLE) :: f1
    REAL(DOUBLE) :: f2
    REAL(DOUBLE) :: t
    REAL(DOUBLE) :: t_a
    REAL(DOUBLE) :: rad
    REAL(DOUBLE) :: rad_a
    REAL(DOUBLE) :: temp
    REAL(DOUBLE) :: temp0
!
    ! initialize local adjoint variables
    t_a=0.
    rad_a=0.
!---To avoid dividing by zero
    IF (.NOT.tem .EQ. 0.) THEN
      f1 = c1*vn**3
      f2 = c2*vn
      t = tem
!---test
!WNPLAN=TEM
!------
      rad_a = wnplan_a
      temp0 = f2/t
      temp = EXP(temp0) - one_dp
      t_a = f1*EXP(temp0)*temp0*rad_a/(temp**2*t)
      tem_a = tem_a + t_a
    END IF
  END SUBROUTINE WNPLAN_A0
  subroutine pack_ossscat(tauabs, tauscat, alpha, temp, tsfc, radout, albedo, nlay, vec, nvec, idir)
    implicit none
    integer, intent(in) :: nlay, nvec, idir
    real (fp) :: tauabs(nlay), tauscat(nlay), alpha(nlay*maxcmu+nlay), temp(nlay+1), tsfc, radout, albedo
    real (fp), intent(inout) :: vec(nvec)

    if (idir .eq. 1) then
       vec(1:nlay)=tauabs
       vec(1+nlay:2*nlay)=tauscat
       vec(1+2*nlay:3*nlay+nlay*maxcmu)=alpha
       vec(1+3*nlay+nlay*maxcmu:4*nlay+nlay*maxcmu+1)=temp
       vec(1+4*nlay+nlay*maxcmu+1:4*nlay+nlay*maxcmu+2)=tsfc
       vec(1+4*nlay+nlay*maxcmu+2:4*nlay+nlay*maxcmu+3)=radout
       vec(1+4*nlay+nlay*maxcmu+3:4*nlay+nlay*maxcmu+4)=albedo
    elseif (idir .eq. -1) then
       tauabs=vec(1:nlay)
       tauscat=vec(1+nlay:2*nlay)
       alpha=vec(1+2*nlay:3*nlay+nlay*maxcmu)
       temp=vec(1+3*nlay+nlay*maxcmu:4*nlay+nlay*maxcmu+1)
       tsfc=vec(4*nlay+nlay*maxcmu+2)
       radout=vec(4*nlay+nlay*maxcmu+3)
       albedo=vec(4*nlay+nlay*maxcmu+4)
    else
       stop 'bad idir'
    end if
    return
  end subroutine pack_ossscat
  subroutine pack_ossscatstep(tauabs, tauscat, alpha, temp, tsfc, radout, albedo, &
       tauext, ssalb, f0, alpha1, rad, azterm, embot, emtop, &
       f, rbot, rtop, sumex, nlay, vec, nvec, idir)
    implicit none
    integer, intent(in) :: nlay, nvec, idir
    real (fp) :: tauabs(nlay), tauscat(nlay), alpha(nlay*maxcmu+nlay), temp(nlay+1), tsfc, radout, albedo
    real (fp) :: tauext(nlay), ssalb(nlay), f0(nlay+1), alpha1(maxcmu+1), rad(mxang)
    real (fp) :: azterm, embot(mxang), emtop(mxang), f
    real (fp) :: rbot(mxang2), rtop(mxang2), sumex
    real (fp), intent(inout) :: vec(nvec)

    if (idir .eq. 1) then
       vec(1:nlay)=tauabs
       vec(1+nlay:2*nlay)=tauscat
       vec(1+2*nlay:3*nlay+nlay*maxcmu)=alpha
       vec(1+3*nlay+nlay*maxcmu:4*nlay+nlay*maxcmu+1)=temp
       vec(4*nlay+nlay*maxcmu+2)=tsfc
       vec(4*nlay+nlay*maxcmu+3)=radout
       vec(4*nlay+nlay*maxcmu+4)=albedo
       vec(1+4*nlay+nlay*maxcmu+4:5*nlay+nlay*maxcmu+4)=tauext
       vec(1+5*nlay+nlay*maxcmu+4:6*nlay+nlay*maxcmu+4)=ssalb
       vec(1+6*nlay+nlay*maxcmu+4:7*nlay+nlay*maxcmu+5)=f0
       vec(1+7*nlay+nlay*maxcmu+5:7*nlay+nlay*maxcmu+maxcmu+6)=alpha1
       vec(1+7*nlay+nlay*maxcmu+maxcmu+6:7*nlay+nlay*maxcmu+maxcmu+mxang+6)=rad
       vec(7*nlay+nlay*maxcmu+maxcmu+mxang+7)=azterm
       vec(1+7*nlay+nlay*maxcmu+maxcmu+mxang+7:7*nlay+nlay*maxcmu+maxcmu+2*mxang+7)=embot
       vec(1+7*nlay+nlay*maxcmu+maxcmu+2*mxang+7:7*nlay+nlay*maxcmu+maxcmu+3*mxang+7)=emtop
       vec(7*nlay+nlay*maxcmu+maxcmu+3*mxang+8)=f
       vec(1+7*nlay+nlay*maxcmu+maxcmu+3*mxang+8:7*nlay+nlay*maxcmu+maxcmu+3*mxang+mxang2+8)=rbot
       vec(1+7*nlay+nlay*maxcmu+maxcmu+5*mxang+mxang2+8:7*nlay+nlay*maxcmu+maxcmu+5*mxang+2*mxang2+8)=rtop
       vec(7*nlay+nlay*maxcmu+maxcmu+5*mxang+2*mxang2+9)=sumex
    elseif (idir .eq. -1) then
       tauabs=vec(1:nlay)
       tauscat=vec(1+nlay:2*nlay)
       alpha=vec(1+2*nlay:3*nlay+nlay*maxcmu)
       temp=vec(1+3*nlay+nlay*maxcmu:4*nlay+nlay*maxcmu+1)
       tsfc=vec(4*nlay+nlay*maxcmu+2)
       radout=vec(4*nlay+nlay*maxcmu+3)
       albedo=vec(4*nlay+nlay*maxcmu+4)
       tauext=vec(1+4*nlay+nlay*maxcmu+4:5*nlay+nlay*maxcmu+4)
       ssalb=vec(1+5*nlay+nlay*maxcmu+4:6*nlay+nlay*maxcmu+4)
       f0=vec(1+6*nlay+nlay*maxcmu+4:7*nlay+nlay*maxcmu+5)
       alpha1=vec(1+7*nlay+nlay*maxcmu+5:7*nlay+nlay*maxcmu+maxcmu+6)
       rad=vec(1+7*nlay+nlay*maxcmu+maxcmu+6:7*nlay+nlay*maxcmu+maxcmu+mxang+6)
       azterm=vec(7*nlay+nlay*maxcmu+maxcmu+mxang+7)
       embot=vec(1+7*nlay+nlay*maxcmu+maxcmu+mxang+7:7*nlay+nlay*maxcmu+maxcmu+2*mxang+7)
       emtop=vec(1+7*nlay+nlay*maxcmu+maxcmu+2*mxang+7:7*nlay+nlay*maxcmu+maxcmu+3*mxang+7)
       f=vec(7*nlay+nlay*maxcmu+maxcmu+3*mxang+8)
       rbot=vec(1+7*nlay+nlay*maxcmu+maxcmu+3*mxang+8:7*nlay+nlay*maxcmu+maxcmu+3*mxang+mxang2+8)
       rtop=vec(1+7*nlay+nlay*maxcmu+maxcmu+5*mxang+mxang2+8:7*nlay+nlay*maxcmu+maxcmu+5*mxang+2*mxang2+8)
       sumex=vec(7*nlay+nlay*maxcmu+maxcmu+5*mxang+2*mxang2+9)
    else
       stop 'bad idir'
    end if
    return
  end subroutine pack_ossscatstep

END MODULE SUBS_OSS_ADDBL_A
