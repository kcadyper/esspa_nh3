!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.1 (r2757) - 01/12/09 17:50
!
!<f90File>**************************************************************
!
! CONTACT:
!
!   Atmospheric & Environmental Research, Inc
!   131 Hartwell Ave
!   Lexington ,MA 02421-3126 USA
!   Phone: 781.761.2288
!   E-mail: guymin@aer.com
!
! COPYRIGHT NOTICE:
!
!   Copyright AER, Inc 2001-2009, All Rights Reserved
!   This software and data are covered by U.S. Patent No. 6,584,405
!   and are delivered with limited rights by AER, Inc.
!   See the file README-DATARIGHTS.txt included with this release
!   for additional details.
!
!*************************************************************</f90File>
!------------------------------------------------------------
!
!  MODULE OSS_ADDBL: contains items needed for the
!                OSS Scattering Adding-Doubling Module
!
!--------------------------------------------------------------
MODULE OSS_ADDBL_A
  USE type_kinds, ONLY: Double, FP
  use params_module, ONLY: mxlay, mxcang, maxcmu, mxang, mxang2, accur
  use subs_oss_addbl
  USE subs_oss_addbl_a
  IMPLICIT NONE
!
! <f90Module>***********************************************************
!
! NAME:
!
!   oss_addbl_a
!
! PURPOSE:
!
!   Contains items needed for the OSS scattering adding-doubling radiative
!   transfer.
!
! INCLUDES:
!
!   None
!
!***********************************************************</f90Module>
  PRIVATE
  PUBLIC ossscat_a

CONTAINS
!  Differentiation of ossscat in reverse (adjoint) mode:
!   gradient, with respect to input variables: temp alpha tauscat
!                tsfc radout tauabs
!   of linear combination of output variables: alpha tauscat radout
  SUBROUTINE OSSSCAT_A(nlay, tauabs, tauabs_a, tauscat, tauscat_a, alpha&
       &    , alpha_a, temp, temp_a, ltypin, vn, nstr, lobs, umu, fbeam, umu0, &
       &    delphi, lamber, emissivity, albedo, albedo_a, hl, tsfc, tsfc_a, deltam, plankin, sbeamin, &
       &    lookup, radout, radout_a, linInTauFlag, istep_in, iangle1_in, testvec, testvec_a)
    IMPLICIT NONE
    !
    !<f90Subroutine>********************************************************
    !
    ! NAME:
    !
    !   OSSSCAT
    !
    ! PURPOSE:
    !
    !   Driver for scattering adding-doubling radiative transfer.
    !
    ! SYNTAX:
    !
    !   CALL OSSSCAT(NLAY, TAUABS, TAUSCAT, ALPHA, TEMP, LTYPIN, VN,
    !      NSTR, LOBS, UMU, FBEAM, UMU0, DELPHI, LAMBER, ALBEDO, HL,
    !      TSFC, DELTAM, PLANKIN, SBEAMIN, LOOKUP, RADOUT)
    !
    ! ARGUMENTS:
    !
    !   INPUTS:
    !
    !   NLAY     INTEGER  Number of atmospheric layers
    !   TAUABS   REAL(FP)     Array of cloud contribution to absorption optical
    !                     depths
    !   TEMP     REAL(FP)     Temperature
    !   LTYPIN   INTEGER  Flag for pointing to cloud active layers
    !   VN       REAL(Double)   Wavenumber, units of cm^-1
    !   NSTR     INTEGER  Number of streams
    !   LOBS     INTEGER  Observer level
    !   UMU      REAL(FP)     Cosine of viewing path angle
    !   FBEAM    REAL(FP)     Solar beam
    !   UMU0     REAL(FP)     Cosine of solar path angle
    !   DELPHI   REAL(FP)     Azimuthal angle offset
    !   LAMBER   LOGICAL  Flag for Lambertian surface
    !   ALBEDO   REAL(FP)     Albedo
    !   HL       REAL(FP)     TBD
    !   TSFC     REAL(FP)     Surface-level air temperature
    !   DELTAM   LOGICAL  Flag for Delta-M scaling
    !   PLANKIN  LOGICAL  Flag for applying Planck function
    !   SBEAMIN  LOGICAL  Flag for solar calculations
    !   LOOKUP   LOGICAL  Flag for up-looking instruments
    !
    !   INPUTS/OUTPUTS:
    !
    !   TAUSCAT  REAL(FP)     Array of cloud contribution to scattering optical
    !                     depths
    !   ALPHA    REAL(FP)     Phase function
    !   RADOUT   REAL(FP)     Radiance for output
    !
    !   * OPTIONAL
    !
    ! INCLUDES:
    !
    !   None
    !
    !*******************************************************</f90Subroutine>
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    !
    ! **** ***********   VERSION 2.0 :    21 MARCH 1995   *****************
    !
    !                       ALGORITHM:    J.L. MONCET
    !                                     S.A. CLOUGH
    !
    !                  IMPLEMENTATION:    J.L. MONCET
    !                                     D.A. PORTMAN
    !
    !               ATMOSPHERIC AND ENVIRONMENTAL RESEARCH INC.
    !               840 MEMORIAL DRIVE,  CAMBRIDGE, MA   02139
    !
    !----------------------------------------------------------------------
    !
    !               WORK SUPPORTED BY:    THE ARM PROGRAM
    !                                     OFFICE OF ENERGY RESEARCH
    !                                     DEPARTMENT OF ENERGY
    !
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    !
    INTEGER, INTENT(IN) :: nlay, nstr
    LOGICAL                  :: linInTauFlag
    integer, parameter :: max_vec0=7*mxlay+mxlay*maxcmu+maxcmu+5*mxang+2*mxang2+9
    integer, parameter :: max_vec =4*mxlay+mxlay*maxcmu+4
    integer :: nvec, nvec0
    REAL(DOUBLE), INTENT(IN) :: vn
    REAL(fp), DIMENSION(nlay) :: tauabs
    REAL(fp), DIMENSION(nlay) :: tauabs_a
    REAL(fp), DIMENSION(nlay) :: tauscat
    REAL(fp), DIMENSION(nlay) :: tauscat_a
    REAL(fp), DIMENSION(0:2*mxcang, nlay) :: alpha
    REAL(fp), DIMENSION(0:2*mxcang, nlay) :: alpha_a
    REAL(fp), DIMENSION(0:nlay) :: temp
    REAL(fp), DIMENSION(0:nlay) :: temp_a
!---- REAL(FP) UMU,UMU0,DELPHI,FBEAM,ACCUR
    REAL(fp), INTENT(IN) :: umu, umu0
    REAL(fp), INTENT(IN) :: delphi, fbeam
    REAL(fp), INTENT(IN) :: albedo, hl(1)
    REAL(fp) :: albedo_a
    REAL(fp) :: tsfc
    REAL(fp) :: tsfc_a
    REAL(fp) :: radout
    REAL(fp) :: radout_a
    integer, intent(in), optional :: istep_in, iangle1_in
    integer :: istep, iangle1
    real (fp), intent(inout), optional :: testvec(max_vec0), testvec_a(max_vec0)
    real (fp) :: saved_nlm(max_vec),saved_ad(max_vec)
    INTEGER, DIMENSION(nlay), INTENT(IN) :: ltypin
    INTEGER, INTENT(IN) :: lobs
    LOGICAL, INTENT(IN) :: deltam, plankin
    LOGICAL, INTENT(IN) :: sbeamin, lookup
    LOGICAL, INTENT(IN) :: lamber

!
    REAL(fp) :: tauext(nlay), ssalb(nlay), f0(0:nlay)
    REAL(fp) :: tauext_a(nlay), ssalb_a(nlay), f0_a(0:nlay)
    REAL(fp) :: alpha1(0:2*mxcang), rad(mxang)
    REAL(fp) :: alpha1_a(0:2*mxcang), rad_a(mxang)
    LOGICAL :: reflb, reflt
    LOGICAL :: plank, sbeam
    INTEGER :: ltyp(nlay)
    REAL(fp) :: azerr, azterm, cl2inv, embot, emml, empl, emtop, f, gmu&
&    , gmu0, gmu0vec, gwt
    REAL(fp) :: azterm_a, embot_a, emml_a, empl_a, emtop_a, f_a
    INTEGER :: i, init, isrfl, k, kconv, l, lnum, maz, n1, n2, n2ang, &
&    nang, nang2, naz, nbot, nbot0, ncang, ntop, ntop0
    REAL(fp) :: pi, pth, rbot, rlay, rtop, sumex, tlay, ylm, ylm0
    REAL(fp) :: rbot_a, rlay_a, rtop_a, sumex_a, tlay_a
    integer :: maz_loopmax, maz_max
    real (fp) :: zero=0.
!
    REAL(fp) :: ttop(mxang2), tbot(mxang2)
    DIMENSION rlay(mxang2), tlay(mxang2), empl(mxang), emml(mxang)
    DIMENSION rlay_a(mxang2), tlay_a(mxang2), empl_a(mxang), emml_a(&
&        mxang)
    DIMENSION rtop(mxang2), emtop(mxang)
    DIMENSION rtop_a(mxang2), emtop_a(mxang)
    DIMENSION rbot(mxang2), embot(mxang)
    DIMENSION rbot_a(mxang2), embot_a(mxang)
    COMMON /angl/ pth(mxang), gmu(mxang), gwt(mxang), gmu0, ylm(0:2*&
&    mxcang-1, mxang), ylm0(0:2*mxcang-1), gmu0vec(1)
    save /angl/
    COMMON /lpar/ plank, sbeam
    save /lpar/
    COMMON /pnlpar/ nang, n2ang, nang2
    save /pnlpar/
    COMMON /constn/ pi, cl2inv
    save /constn/
    SAVE init
    INTEGER :: arg1
    INTEGER :: arg2
    INTEGER :: branch
    INTEGER :: ad_from
    INTEGER :: ad_from0
    REAL(fp) :: temp0_a
    INTRINSIC COS
    INTRINSIC EXP
    INTRINSIC ABS
    REAL(fp) :: temp0_a0
    INTRINSIC LOG
    INTRINSIC ACOS
    REAL(fp) :: abs2
    REAL(fp) :: abs1
   REAL(FP),                           INTENT(IN)    :: emissivity
!
    DATA init /1/
    ! Initialize local adjoint variables:
    tauext_a(1:nlay) = 0.0
    f0_a(0:nlay) = 0.0
    alpha1_a(:) = 0.0
    empl_a(:) = 0.0
    emml_a(:) = 0.0
    ssalb_a(1:nlay) = 0.0
    rad_a(:) = 0.0
    tlay_a(1:mxang2) = 0.0
    rlay_a(1:mxang2) = 0.0
    azterm_a = 0.0
    embot_a = 0.0
    emtop_a = 0.0
    rbot_a = 0.0
    rtop_a = 0.0
    f_a = 0.0
    sumex_a = 0.0
!
    plank = plankin
    sbeam = sbeamin
    ltyp(1:nlay) = ltypin(1:nlay)
!
    if (present(istep_in)) then
       istep=istep_in
    else
       istep=10000
    end if
    if (present(iangle1_in)) then
       iangle1=iangle1_in
    else
       iangle1=0
    end if
    if (istep .le. 9) then
       ! zero out local arrays to prevent using unitialized values in packing calls
       ! first save non-local nlm values
       nvec0=7*nlay+nlay*maxcmu+maxcmu+5*mxang+2*mxang2+9
       nvec =4*nlay+nlay*maxcmu+4
       call pack_ossscat(tauabs, tauscat, alpha, temp, tsfc, radout, albedo, nlay, saved_nlm, nvec, +1)
       ! then zero out all of nlm (non-local + local)
       testvec(1:nvec0)=zero ! zero out testvec(1:nvec0)
       call pack_ossscatstep(tauabs, tauscat, alpha, temp, tsfc, radout, albedo, &
            tauext, ssalb, f0, alpha1, rad, azterm, embot, emtop, &
            f, rbot, rtop, sumex, nlay, testvec, nvec0, -1)
       ! then restore non-local nlm values
       call pack_ossscat(tauabs, tauscat, alpha, temp, tsfc, radout, albedo, nlay, saved_nlm, nvec, -1)
       ! THEN: initialize non-local + local adjoint arrays from testvec_a
       call pack_ossscatstep(tauabs_a, tauscat_a, alpha_a, temp_a, tsfc_a, radout_a, albedo_a, &
            tauext_a, ssalb_a, f0_a, alpha1_a, rad_a, azterm_a, embot_a, emtop_a, &
            f_a, rbot_a, rtop_a, sumex_a, nlay, testvec_a, nvec0, -1)
    end if !istep .le. 9

    IF (init .EQ. 1) THEN

      call init_fac_pp()
! ======================================================================
! === INITIALIZATION ===================================================
! ======================================================================
      pi = ACOS(-1.)
      cl2inv = 1./LOG(2.)
!
      ncang = nstr/2
!
!-----Generate discrete angles and associated weights for
!-----Double-Gauss" quadrature (see Stamnes, 1981)
!
      CALL QGAUSN(ncang, gmu, gwt)
!
      nang = ncang + 1
      n2ang = 2*nang
      nang2 = nang*nang
    END IF
!
! *** Insert user angle.
!
    gmu(nang) = umu
!
! *** Set NAZ
!
    naz = 0
    IF (sbeam) THEN
      gmu0 = umu0
      IF (1. - gmu0 .GT. 1.e-05 .AND. 1. - gmu(nang) .GT. 1.e-05) naz = &
&          n2ang - 3
    END IF
!
! *** Set control parameters for CHARTS run
!
    IF (lamber) THEN
       isrfl = -1
       IF (albedo .LE. 1.e-6) isrfl = 0
    ELSE
       isrfl = 2
       IF (albedo .LE. 1.e-6) isrfl = 0
       !STOP 'OSSSCAT: This version only supports Lambertian surfaces'
    ENDIF
!
    CALL SETCTL(nlay, ltyp, lobs, sbeam, plank, isrfl, lookup, naz, &
         &            nbot0, nbot, ntop0, ntop)
!
!!$    n1 = ntop0
!!$    n2 = nbot0
!
! *** Delta-M scaling
!
    f = 0.
    DO i=1,nlay
       IF (deltam) THEN
          CALL PUSHREALFP(f)
          f = alpha(n2ang-2, i)
          CALL PUSHREALFP(tauscat(i))
          tauscat(i) = tauscat(i)*(1.-f)
       END IF
!
       DO l=0,n2ang-3
          CALL PUSHREALFP(alpha(l, i))
          alpha(l, i) = (2*l+1)*(alpha(l, i)-f)/(1.-f)
        END DO
     END DO
!
     if (istep .gt. 1) then
     DO l=1,nlay
        tauext(l) = tauabs(l)
        IF (ltyp(l) .GT. 0) THEN
           tauext(l) = tauext(l) + tauscat(l)
           IF (tauext(l) .LE. 0.) THEN
              ssalb(l) = 0.
              CALL PUSHINTEGER4(2)
           ELSE
              ssalb(l) = tauscat(l)/tauext(l)
              CALL PUSHINTEGER4(3)
           END IF
        ELSE
           CALL PUSHINTEGER4(1)
        END IF
     END DO

     if (istep .gt. 2) then

     !
     IF (sbeam) THEN
        !
        !-----Compute solar beam extinction (current version does not treat
        !-----specularly reflected beam)
        !
        sumex = 0.
        f0(0) = fbeam
        DO l=1,nlay
           CALL PUSHREALFP(sumex)
           !-----Add scattering component to total extinction
           sumex = sumex + tauext(l)
           !-----Calculate solar irradiance at top of scattering layer
           f0(l) = fbeam*EXP(-(sumex/gmu0))
        END DO
     END IF
     if (istep .gt. 3) then
     !
     ! =====================================================================
     ! === BEGIN LOOP OVER AZIMUTHAL ANGLES ================================
     ! =====================================================================
     maz_loopmax=naz
     if (istep .le. 8) maz_loopmax=min(naz,iangle1)
     kconv = 0
     DO maz=0,maz_loopmax
        Ttop = 0.
        Tbot = 0.
       do k=1, nang2, nang+1
          TTOP(k) = 1.0
          TBOT(k) = 1.0
       end do

        maz_max = maz
        CALL LOC_PUSHREAL4ARRAY(embot, fac_pp*mxang)
        embot = 0.
        CALL LOC_PUSHREAL4ARRAY(emtop, fac_pp*mxang)
        emtop = 0.
        CALL LOC_PUSHREAL4ARRAY(rtop, fac_pp*mxang2)
        rtop = 0.
        CALL LOC_PUSHREAL4ARRAY(rbot, fac_pp*mxang2)
        rbot = 0.
        !
        ! *** Generate normalized Legendre polynomials for computational angles
        ! *** (GMU) and for incident solar beam angle cosine (GMU0).
        !
        arg1 = 2*mxcang - 1
        arg2 = n2ang - 3
        CALL LOC_PUSHREAL4ARRAY(ylm, 2*mxcang*fac_pp*mxang)
        CALL LEPOLY_OSS(nang, maz, arg1, arg2, gmu, ylm)
        !     --Put GMU0 in vector form to prevent compiler error:
        gmu0vec(1) = gmu0
        IF (sbeam) THEN
           arg1 = 2*mxcang - 1
           arg2 = n2ang - 3
           CALL LEPOLY_OSS(1, maz, arg1, arg2, gmu0vec, ylm0)
        END IF
        CALL PUSHBOOLEAN(reflt)
        !      IF(SBEAM)CALL LEPOLY_OSS(1,MAZ,2*MXCANG-1,N2ANG-3,GMU0,YLM0)
        !
        !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        !     LOOP OVER LAYERS THE ABOVE OBSERVER LEVEL - MERGE DOWN CASE      +
        !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        reflt = .false.
        if (maz .eq. 0) then
           ad_from = ntop0
        else
           ad_from = ntop
        end if
        !
        DO lnum=ad_from,lobs-1
           !
           IF (ltyp(lnum) .LE. 0) THEN
              CALL LOC_PUSHREAL4ARRAY(emml, fac_pp*mxang)
              CALL LOC_PUSHREAL4ARRAY(empl, fac_pp*mxang)
              CALL LOC_PUSHREAL4ARRAY(tlay, fac_pp*mxang2)
              !-----------------------------------------------------------------------
              !     CLEAR LAYER CASE:
              !-----------------------------------------------------------------------
              ! *** Accumulate partial results for successive clear layers "LAYDAT: rlay, tlay, empl, emml".
              ! *** Final merge with results contained in "ACMDWN: rtop, emtop" done at the end,
              ! *** when (LTYP=-99 OR -100).
              CALL CLRLAY(tauext(lnum), temp(lnum-1), temp(lnum), reflt, &
                   &                  ltyp(lnum), vn, tlay, empl, emml, 0._fp, linInTauFlag)
              IF (ltyp(lnum) .LE. -99) THEN
                 CALL LOC_PUSHREAL4ARRAY(emtop, fac_pp*mxang)
                 CALL LOC_PUSHREAL4ARRAY(rtop, fac_pp*mxang2)
                 CALL ADDCLR(rtop, ttop, emtop, reflt, plank, tlay, empl, &
                      &                    emml)
                 CALL PUSHINTEGER4(2)
              ELSE
                 CALL PUSHINTEGER4(1)
              END IF
           ELSE
              !-----------------------------------------------------------------------
              !     CLOUDY LAYER CASE:
              !-----------------------------------------------------------------------
              ! *** Calculate reflection/transmission matrices (in RLAY and TLAY) and
              ! *** internal sources (EMPL-upward- and EMML-downward) for current layer
              !
              DO k=0,n2ang-2
                 CALL PUSHREALFP(alpha1(k))
                 alpha1(k) = alpha(k, lnum)
              END DO
              CALL LOC_PUSHREAL4ARRAY(emml, fac_pp*mxang)
              CALL LOC_PUSHREAL4ARRAY(tlay, fac_pp*mxang2)
              CALL LOC_PUSHREAL4ARRAY(rlay, fac_pp*mxang2)
              call pushrealfp(tauext(lnum))
              call pushrealfp(ssalb(lnum))
              call pushrealfp(temp(lnum-1))
              call pushrealfp(temp(lnum))
              call pushrealfp(f0(lnum-1))
              call LOC_PUSHREAL4ARRAY(empl, fac_pp*mxang)
              CALL MSLAY(tauext(lnum), ssalb(lnum), temp(lnum-1), temp(&
                   &                 lnum), f0(lnum-1), rlay, tlay, empl, emml, maz, vn, &
                   &                 alpha1, 0, linInTauFlag)
              CALL PUSHBOOLEAN(reflt)
              CALL LOC_PUSHREAL4ARRAY(emtop, fac_pp*mxang)
              CALL LOC_PUSHREAL4ARRAY(rtop, fac_pp*mxang2)
              call LOC_PUSHREAL4ARRAY(tlay, fac_pp*mxang2)
              call LOC_PUSHREAL4ARRAY(rlay, fac_pp*mxang2)
              call LOC_PUSHREAL4ARRAY(emml, fac_pp*mxang)
              call LOC_PUSHREAL4ARRAY(empl, fac_pp*mxang)
              call pushrealfp(ttop(1))
              !
              ! *** Accumulate results in ACMWDN: rtop, emtop
              !
              CALL ADDMS(rtop, ttop, emtop, reflt, rlay, tlay, empl, emml)
              CALL PUSHINTEGER4(3)
           END IF
        END DO
!!$        CALL PUSHINTEGER4(ad_from)

        if (istep .gt. 4 .or. maz .lt. maz_loopmax) then
        CALL PUSHBOOLEAN(reflb)

        !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        !     LOOP OVER LAYERS BELOW THE OBSERVER LEVEL - MERGE UP CASE        +
        !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        !
        ! *** Initialize RBOT and EMBOT
        !
        CALL SURFCE(maz, isrfl, tsfc, albedo, f0(nlay), rbot, embot, &
             &              reflb, vn, emissivity)

        if (istep .gt. 5 .or. maz .lt. maz_loopmax) then

        if (maz .eq. 0) then
           ad_from0 = nbot0
        else
           ad_from0 = nbot
        end if
        !
        DO lnum=ad_from0,lobs,-1
           !
           IF (ltyp(lnum) .LE. 0) THEN
              CALL LOC_PUSHREAL4ARRAY(emml, fac_pp*mxang)
              CALL LOC_PUSHREAL4ARRAY(empl, fac_pp*mxang)
              CALL LOC_PUSHREAL4ARRAY(tlay, fac_pp*mxang2)
              !-----------------------------------------------------------------------
              !     CLEAR LAYER CASE:
              !-----------------------------------------------------------------------
              ! *** Accumulate partial results for successive clear layers "LAYDAT".
              ! *** Final merge with results contained in "ACMUP: rbot, embot" done at the end,
              ! *** when (LTYP=-99 OR -100).
              CALL CLRLAY(tauext(lnum), temp(lnum), temp(lnum-1), reflb, &
                   &                  ltyp(lnum), vn, tlay, empl, emml, 0._fp, linInTauFlag)
              IF (ltyp(lnum) .LE. -99) THEN
                 CALL LOC_PUSHREAL4ARRAY(embot, fac_pp*mxang)
                 CALL LOC_PUSHREAL4ARRAY(rbot, fac_pp*mxang2)
                 CALL ADDCLR(rbot, tbot, embot, reflb, plank, tlay, empl, &
                      &                    emml)
                 CALL PUSHINTEGER4(2)
              ELSE
                 CALL PUSHINTEGER4(1)
              END IF
           ELSE
              !-----------------------------------------------------------------------
              !     CLOUDY LAYER CASE:
              !-----------------------------------------------------------------------
              ! *** Calculate reflection/transmission matrices (in RLAY and TLAY) and
              ! *** internal sources (EMPL-upward- and EMML-downward) for current layer
              !
              DO k=0,n2ang-2
                 CALL PUSHREALFP(alpha1(k))
                 alpha1(k) = alpha(k, lnum)
              END DO
              CALL LOC_PUSHREAL4ARRAY(emml, fac_pp*mxang)
              CALL LOC_PUSHREAL4ARRAY(tlay, fac_pp*mxang2)
              CALL LOC_PUSHREAL4ARRAY(rlay, fac_pp*mxang2)
              call pushrealfp(tauext(lnum))
              call pushrealfp(ssalb(lnum))
              call pushrealfp(temp(lnum-1))
              call pushrealfp(temp(lnum))
              call pushrealfp(f0(lnum-1))
              call LOC_PUSHREAL4ARRAY(empl, fac_pp*mxang)
              CALL MSLAY(tauext(lnum), ssalb(lnum), temp(lnum), temp(lnum-&
                   &                 1), f0(lnum-1), rlay, tlay, empl, emml, maz, vn, alpha1&
                   &                 , 1, linInTauFlag)
              CALL PUSHBOOLEAN(reflb)
              CALL LOC_PUSHREAL4ARRAY(embot, fac_pp*mxang)
              CALL LOC_PUSHREAL4ARRAY(rbot, fac_pp*mxang2)
              call LOC_PUSHREAL4ARRAY(tlay, fac_pp*mxang2)
              call LOC_PUSHREAL4ARRAY(rlay, fac_pp*mxang2)
              call LOC_PUSHREAL4ARRAY(emml, fac_pp*mxang)
              call LOC_PUSHREAL4ARRAY(empl, fac_pp*mxang)
              call pushrealfp(ttop(1))
              !
              ! *** Accumulate results.
              !
              CALL ADDMS(rbot, tbot, embot, reflb, rlay, tlay, empl, emml)
              CALL PUSHINTEGER4(3)
           END IF
        END DO
!!$        CALL PUSHINTEGER4(ad_from0)

        if (istep .gt. 6 .or. maz .lt. maz_loopmax) then

        !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        !     DO FINAL MERGE  - Output radiances in RAD                        +
        !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        IF (lookup) THEN
           CALL MRGRAD(rtop, emtop, rbot, embot, reflt, reflb, rad)
!!$           CALL PUSHINTEGER4(0)
        ELSE
           CALL MRGRAD(rbot, embot, rtop, emtop, reflb, reflt, rad)
!!$           CALL PUSHINTEGER4(1)
        END IF

        if (istep .gt. 7 .or. maz .lt. maz_loopmax) then

        ! =====================================================================
        ! === END OF PANEL LOOP ===============================================
        ! =====================================================================
        IF (maz .EQ. 0) THEN
           radout = rad(nang)
           CALL PUSHBOOLEAN(plank)
           ! *** (Reset control parameters for MAZ >0)
           plank = .false.
!!$           n1 = nbot
!!$           n2 = ntop
!!$           CALL PUSHINTEGER4(2)
        ELSE
           ! *** Compute radiance scaling for azimuthal order MAZ
           azterm = rad(nang)*COS(maz*delphi*pi/180.)
           radout = radout + azterm
           !
           IF (radout .NE. 0.) THEN
              IF (azterm .GE. 0.) THEN
                 abs1 = azterm
              ELSE
                 abs1 = -azterm
              END IF
              IF (radout .GE. 0.) THEN
                 abs2 = radout
              ELSE
                 abs2 = -radout
              END IF
              azerr = abs1/abs2
              IF (azerr .LE. accur) kconv = kconv + 1
           END IF
           !
           IF (kconv .GE. 2) THEN
              GOTO 100
!!$           ELSE
!!$              CALL PUSHINTEGER4(3)
           END IF
        END IF
        endif ! istep > 7
        endif ! istep > 6
        endif ! istep > 5
        endif ! istep > 4
     END DO  !maz=0,maz_loopmax for NLM recomputation
!!$     GOTO 110
100  continue ! exit maz loop for kconv >= 2
!    Initialization of adjoint dummy arguments (forward model input variables):
!!$     temp_a(0:nlay) = 0.0
!!$     tsfc_a = 0.0
!    Args that are not intialized (forward model output variables):
!    tauscat_a, alpha_a, radout_a

!!$     GOTO 130
!!$110  temp_a(0:nlay) = 0.0
!!$     tsfc_a = 0.0
!!$     tauext_a(1:nlay) = 0.0
!!$     f0_a(0:nlay) = 0.0
!!$     alpha1_a(:) = 0.0
!!$     empl_a(:) = 0.0
!!$     emml_a(:) = 0.0
!!$     ssalb_a(1:nlay) = 0.0
!!$     rad_a(:) = 0.0
!!$     tlay_a(1:mxang2) = 0.0
!!$     rlay_a(1:mxang2) = 0.0
     do maz=maz_max,0,-1
!!$120  CALL POPINTEGER4(maz)
!!$     CALL POPINTEGER4(branch)
        ! TBD:  .or. maz .lt. maz_loopmax not needed??
        if (istep .gt. 7 .or. maz .lt. maz_loopmax) then
        if (maz .eq. 0) then
!!$     IF (branch .LT. 2) THEN
!!$        GOTO 150
!!$     ELSE IF (branch .LT. 3) THEN
           CALL POPBOOLEAN(plank)
           rad_a(nang) = rad_a(nang) + radout_a
           radout_a = 0.0
        else
!!$        GOTO 140
!!$     END IF
!!$130     azterm_a = radout_a
           azterm_a = radout_a
           rad_a(nang) = rad_a(nang) + COS(maz/180.*(delphi*pi))*azterm_a
        end if
        endif !istep > 7
!!$
!!$140  CALL POPINTEGER4(branch)
        if (istep .gt. 6 .or. maz .lt. maz_loopmax) then
        IF (lookup) THEN
           CALL MRGRAD_A(rtop, rtop_a, emtop, emtop_a, rbot, rbot_a, embot&
                &                , embot_a, reflt, reflb, rad, rad_a)
        ELSE
           CALL MRGRAD_A(rbot, rbot_a, embot, embot_a, rtop, rtop_a, emtop&
                &                , emtop_a, reflb, reflt, rad, rad_a)
        END IF
        endif ! istep > 6

        if (istep .gt. 5 .or. maz .lt. maz_loopmax) then

        if (maz .eq. 0) then
           ad_from0 = nbot0
        else
           ad_from0 = nbot
        end if
        DO lnum=lobs,ad_from0,1
           CALL POPINTEGER4(branch)
           IF (branch .LT. 3) THEN
              IF (.NOT.branch .LT. 2) THEN
                ! no longer needed:
                 tlay_a(1:mxang2)=0.
                 empl_a(1:mxang)=0.
                 emml_a(1:mxang)=0.
                 CALL LOC_POPREAL4ARRAY(rbot, fac_pp*mxang2)
                 CALL LOC_POPREAL4ARRAY(embot, fac_pp*mxang)
                 CALL ADDCLR_A(rbot, rbot_a, tbot, embot, embot_a, reflb, &
                      &                    plank, tlay, tlay_a, empl, empl_a, emml, emml_a)
              END IF
              CALL LOC_POPREAL4ARRAY(tlay, fac_pp*mxang2)
              CALL LOC_POPREAL4ARRAY(empl, fac_pp*mxang)
              CALL LOC_POPREAL4ARRAY(emml, fac_pp*mxang)
              CALL CLRLAY_A(tauext(lnum), tauext_a(lnum), temp(lnum), temp_a&
                   &                  (lnum), temp(lnum-1), temp_a(lnum-1), reflb, ltyp(lnum&
                   &                  ), vn, tlay, tlay_a, empl, empl_a, emml, emml_a, linInTauFlag)
           ELSE
              ! no longer needed:
              rlay_a(1:mxang2)=0.
              tlay_a(1:mxang2)=0.
              empl_a(1:mxang)=0.
              emml_a(1:mxang)=0.
              call poprealfp(ttop(1))
              call LOC_POPREAL4ARRAY(empl, fac_pp*mxang)
              call LOC_POPREAL4ARRAY(emml, fac_pp*mxang)
              call LOC_POPREAL4ARRAY(rlay, fac_pp*mxang2)
              call LOC_POPREAL4ARRAY(tlay, fac_pp*mxang2)
              CALL LOC_POPREAL4ARRAY(rbot, fac_pp*mxang2)
              CALL LOC_POPREAL4ARRAY(embot, fac_pp*mxang)
              CALL POPBOOLEAN(reflb)
              CALL ADDMS_A(rbot, rbot_a, tbot, embot, embot_a, reflb, rlay, &
                   &                 rlay_a, tlay, tlay_a, empl, empl_a, emml, emml_a)
              call LOC_POPREAL4ARRAY(empl, fac_pp*mxang)
              call poprealfp(f0(lnum-1))
              call poprealfp(temp(lnum))
              call poprealfp(temp(lnum-1))
              call poprealfp(ssalb(lnum))
              call poprealfp(tauext(lnum))
              CALL LOC_POPREAL4ARRAY(rlay, fac_pp*mxang2)
              CALL LOC_POPREAL4ARRAY(tlay, fac_pp*mxang2)
              CALL LOC_POPREAL4ARRAY(emml, fac_pp*mxang)
              CALL MSLAY_A(tauext(lnum), tauext_a(lnum), ssalb(lnum), &
                   &                 ssalb_a(lnum), temp(lnum), temp_a(lnum), temp(lnum-1), &
                   &                 temp_a(lnum-1), f0(lnum-1), f0_a(lnum-1), rlay, rlay_a&
                   &                 , tlay, tlay_a, empl, empl_a, emml, emml_a, maz, vn, &
                   &                 alpha1, alpha1_a, 1, linInTauFlag)
              DO k=n2ang-2,0,-1
                 CALL POPREALFP(alpha1(k))
                 alpha_a(k, lnum) = alpha_a(k, lnum) + alpha1_a(k)
                 alpha1_a(k) = 0.0
              END DO
           END IF
        END DO !lnum=lobs,ad_from0,1
        endif !istep > 5

        if (istep .gt. 4 .or. maz .lt. maz_loopmax) then
        CALL POPBOOLEAN(reflb)

        CALL SURFCE_A(maz, isrfl, tsfc, tsfc_a, albedo, albedo_a, f0(nlay), f0_a(&
             &              nlay), rbot, rbot_a, embot, embot_a, reflb, vn, emissivity)

        endif !istep > 4

        if (maz .eq. 0) then
           ad_from = ntop0
        else
           ad_from = ntop
        end if
        DO lnum=lobs-1,ad_from,-1
           CALL POPINTEGER4(branch)
           IF (branch .LT. 3) THEN
              IF (.NOT.branch .LT. 2) THEN
                ! no longer needed:
                 tlay_a(1:mxang2)=0.
                 empl_a(1:mxang)=0.
                 emml_a(1:mxang)=0.
                 CALL LOC_POPREAL4ARRAY(rtop, fac_pp*mxang2)
                 CALL LOC_POPREAL4ARRAY(emtop, fac_pp*mxang)
                 CALL ADDCLR_A(rtop, rtop_a, ttop, emtop, emtop_a, reflt, &
                      &                    plank, tlay, tlay_a, empl, empl_a, emml, emml_a)
              END IF
              CALL LOC_POPREAL4ARRAY(tlay, fac_pp*mxang2)
              CALL LOC_POPREAL4ARRAY(empl, fac_pp*mxang)
              CALL LOC_POPREAL4ARRAY(emml, fac_pp*mxang)
              CALL CLRLAY_A(tauext(lnum), tauext_a(lnum), temp(lnum-1), &
                   &                  temp_a(lnum-1), temp(lnum), temp_a(lnum), reflt, ltyp(&
                   &                  lnum), vn, tlay, tlay_a, empl, empl_a, emml, emml_a, linInTauFlag)
           ELSE
              ! no longer needed:
              rlay_a(1:mxang2)=0.
              tlay_a(1:mxang2)=0.
              empl_a(1:mxang)=0.
              emml_a(1:mxang)=0.
              call poprealfp(ttop(1))
              call LOC_POPREAL4ARRAY(empl, fac_pp*mxang)
              call LOC_POPREAL4ARRAY(emml, fac_pp*mxang)
              call LOC_POPREAL4ARRAY(rlay, fac_pp*mxang2)
              call LOC_POPREAL4ARRAY(tlay, fac_pp*mxang2)
              CALL LOC_POPREAL4ARRAY(rtop, fac_pp*mxang2)
              CALL LOC_POPREAL4ARRAY(emtop, fac_pp*mxang)
              CALL POPBOOLEAN(reflt)
              CALL ADDMS_A(rtop, rtop_a, ttop, emtop, emtop_a, reflt, rlay, &
                   &                 rlay_a, tlay, tlay_a, empl, empl_a, emml, emml_a)
              call LOC_POPREAL4ARRAY(empl, fac_pp*mxang)
              call poprealfp(f0(lnum-1))
              call poprealfp(temp(lnum))
              call poprealfp(temp(lnum-1))
              call poprealfp(ssalb(lnum))
              call poprealfp(tauext(lnum))
              CALL LOC_POPREAL4ARRAY(rlay, fac_pp*mxang2)
              CALL LOC_POPREAL4ARRAY(tlay, fac_pp*mxang2)
              CALL LOC_POPREAL4ARRAY(emml, fac_pp*mxang)
              CALL MSLAY_A(tauext(lnum), tauext_a(lnum), ssalb(lnum), &
                   &                 ssalb_a(lnum), temp(lnum-1), temp_a(lnum-1), temp(lnum)&
                   &                 , temp_a(lnum), f0(lnum-1), f0_a(lnum-1), rlay, rlay_a&
                   &                 , tlay, tlay_a, empl, empl_a, emml, emml_a, maz, vn, &
                   &                 alpha1, alpha1_a, 0, linInTauFlag)
              DO k=n2ang-2,0,-1
                 CALL POPREALFP(alpha1(k))
                 alpha_a(k, lnum) = alpha_a(k, lnum) + alpha1_a(k)
                 alpha1_a(k) = 0.0
              END DO
           END IF
        END DO !lnum=lobs-1,ad_from,-1
        CALL POPBOOLEAN(reflt)
        CALL LOC_POPREAL4ARRAY(ylm, 2*mxcang*fac_pp*mxang)
        CALL LOC_POPREAL4ARRAY(rbot, fac_pp*mxang2)
        CALL LOC_POPREAL4ARRAY(rtop, fac_pp*mxang2)
        CALL LOC_POPREAL4ARRAY(emtop, fac_pp*mxang)
        CALL LOC_POPREAL4ARRAY(embot, fac_pp*mxang)
     end do !maz=maz_max,0,-1
     endif !istep .gt. 3
!!$150  IF (.NOT.branch .LT. 1) THEN
     IF (sbeam) THEN
        sumex_a = 0.0
        DO l=nlay,1,-1
           sumex_a = sumex_a - fbeam*EXP(-(sumex/gmu0))*f0_a(l)/gmu0
           f0_a(l) = 0.0
           CALL POPREALFP(sumex)
           tauext_a(l) = tauext_a(l) + sumex_a
        END DO
     END IF
     endif !istep .gt. 2
!!$     tauabs_a(1:nlay) = 0.0
     DO l=nlay,1,-1
        CALL POPINTEGER4(branch)
        IF (branch .LT. 3) THEN
           IF (branch .LT. 2) THEN !ltyp .le. 0
              GOTO 160
           ELSE !ltyp .gt. 0 .and. tauext .le. 0
              ssalb_a(l) = 0.0
           END IF
        ELSE !ltyp .gt. 0 .and. tauext .gt. 0
           temp0_a0 = ssalb_a(l)/tauext(l)
           tauscat_a(l) = tauscat_a(l) + temp0_a0
           tauext_a(l) = tauext_a(l) - tauscat(l)*temp0_a0/tauext(l)
           ssalb_a(l) = 0.0
        END IF
        tauscat_a(l) = tauscat_a(l) + tauext_a(l)
160     tauabs_a(l) = tauabs_a(l) + tauext_a(l)
        tauext_a(l) = 0.0
     END DO
     endif ! istep .gt .1
     f_a = 0.0
     DO i=nlay,1,-1
        DO l=n2ang-3,0,-1
           CALL POPREALFP(alpha(l, i))
           temp0_a = (2*l+1)*alpha_a(l, i)/(1.-f)
           f_a = f_a + ((alpha(l, i)-f)/(1.-f)-1.0)*temp0_a
           alpha_a(l, i) = temp0_a
        END DO
        IF (deltam) THEN
           CALL POPREALFP(tauscat(i))
           f_a = f_a - tauscat(i)*tauscat_a(i)
           tauscat_a(i) = (1.-f)*tauscat_a(i)
           CALL POPREALFP(f)
           alpha_a(n2ang-2, i) = alpha_a(n2ang-2, i) + f_a
           f_a = 0.0
        END IF
     END DO
   END SUBROUTINE OSSSCAT_A
 END MODULE OSS_ADDBL_A
